<sapia:page title="Regis" xmlns:sapia="http://www.sapia-oss.org/2003/XSL/Transform">
  <sapia:vmenu>
    <sapia:vsection name="Project Home" href="home.html"/>
    <sapia:vsection name="Javadoc" href="maven/api/index.html"/>
    <sapia:vsection name="Download" href="download.html"/>
    <sapia:vsection name="Mailing List" href="list.html"/>
    <sapia:vsection name="Maven" href="maven/index.html"/>
  </sapia:vmenu>
  <sapia:sect1 title="Regis">
    <sapia:section>
      <sapia:path name="home" href="../../home.html" />
      <sapia:path name="projects" />
    </sapia:section>
    <toc/>
    <sapia:sect2 title="Overview">
      <p>Regis stands for "registry". It implements a hierarchical configuration registry 
      that is meant to externalize application configuration. Three main objectives triggered
      the launch of this project:</p>
      <ul>
        <li>To provide a powerful, well-designed configuration framework.</li>
        <li>To allow for configuration persistency (currently using Hibernate and Prevayler).</li>
        <li>To allow for distributed configuration (currently through Sapia's
         <a target="ubik" href="http://www.sapia-oss.org/projects/ubik">Ubik</a> distributed computing framework).</li>
      </ul>
    </sapia:sect2>
    
    <sapia:sect2 title="Features">
      <ul>
        <li>Multiple implementations: in-memory, persistent (based on Hibernate), distributed, cached.</li>
        <li>Variable interpolation.</li>
        <li>Configuration reuse (through node inheritance, inclusion, linking).</li>        
        <li>XML-based configuration loading.</li>
        <li>Conditional directives.</li>        
        <li>Simple API.</li>
      </ul>
      <p/>
      
      <sapia:note>
      A presentation of Regis' different usage patterns is <a target="usage_pdf" href="UsagePatterns.pdf">available</a>.
      </sapia:note>
    </sapia:sect2>
    
    <sapia:sect2 title="Design">
      <p>Regis is designed as follows:</p>
      <ul>
        <li>A  <sapia:class link="api/org/sapia/regis/Registry.html" target="target_window">Registry</sapia:class> is a  
            hierarchy of <sapia:class link="api/org/sapia/regis/Node.html" target="target_window">Node</sapia:class>s.</li>        
        <li>A Registry has a single root Node.</li>                
        <li>A Registry is typically instantiated through a  
            <sapia:class link="api/org/sapia/regis/RegistryFactory.html" target="target_window">RegistryFactory</sapia:class>.</li>
        <li>A Node has a name (identifying it uniquely under its parent Node), and an absolute   
            <sapia:class link="api/org/sapia/regis/Path.html" target="target_window">Path</sapia:class>, representing the Node's
            fully qualified name, starting from the root Node.</li>
        <li>The <sapia:class link="api/org/sapia/regis/RWNode.html" target="target_window">RWNode</sapia:class>
            interface is implemented by Nodes that provide "write" operations.</li>
      </ul>
    </sapia:sect2>
    
    <sapia:sect2 title="Learning by Example">
      <sapia:sect-desc>
       <p>The examples illustrate how to use Regis, from an application programming
       perspective. For more details, see the <a target="javadoc" href="api/index.html">javadoc</a>.</p>
       
       <p>The general usage pattern involves:</p>
       <ul>
         <li>Acquiring a registry (usually through a <sapia:class>RegistryProvider</sapia:class>).</li>
         <li>Opening a <sapia:class>RegistrySession</sapia:class>. </li>
         <li>Performing the desired registry operations.</li>
         <li>Closing the session.</li>
       </ul>
      </sapia:sect-desc>
      
      <sapia:sect3 title="The Regis API">
      
        <sapia:sect4 title="Acquiring the Root Node">
<sapia:code>
import org.sapia.regis.*

...
Registry reg = // here acquire registry 
RegisSession session = reg.open();
try{
  Node root = reg.getRoot();
  ...
}finally{
  session.close();
}
...
</sapia:code>
        </sapia:sect4>
        
        <sapia:sect4 title="Looking up a Node">
<sapia:code>
// by name
Node child = root.getChild("someName");

// by path
child = root.getChild(
  Path.parse("level_one/level_two/child"));

// by query
child = root.getChild(
  Query.create("level_one/level_two/child")
  .addCrit("prop1", "value1")
  .addCrit("prop2", "value2"));
</sapia:code>
        </sapia:sect4>
        
        <sapia:sect4 title="Creating a Node">
<sapia:code>
// if the implementation you use is an instance 
// of RWNode, you cast it and have access to
// write-operations on the node. Futhermore, your session
// must also support write operations (if that is the
// case you can cast it to a RWSession)

RWSession rwSess = (RWSession)session;
RWNode rwRoot = (RWNode)root;
rwSess.begin();
try{
  Node child = rwRoot.createChild("someChild");
  rwSess.commit();
}
catch(RuntimeException e){
  rwSess.rollback();
}
  
</sapia:code>
        </sapia:sect4>        
        
        <sapia:sect4 title="Getting Properties">
<sapia:code>
Property timeout = child.getProperty("timeoutMillis");
if(timeout.isNull()){
  throw new IllegalStateException("Timeout not specified");
}
else{
  long to = timeout.asLong();
  ...
}

Map properties = child.getProperties();
String timeoutStr = (String)properties.get("timeoutMillis");
...
</sapia:code>
        </sapia:sect4>                        
        
        <sapia:sect4 title="Child Nodes">
<sapia:code>
Iterator children = parent.getChildren();
while(children.hasNext()){
  Node child = (Node)children.next();
  System.out.println("Got child: " + child.getName());
}
</sapia:code>
        </sapia:sect4>
        
        <sapia:sect4 title="Interpolation">
<sapia:code>
Map vars = new HashMap();
vars.put("cache.dir", System.getProperty("user.dir"));

// let's say stored property value is ${cache.dir}/sessionCache
Property prop = node.renderProperty("cacheDir", vars);
</sapia:code>
        </sapia:sect4>        
        
        <sapia:sect4 title="Various Methods">
<sapia:code>
System.out.println("Name: " + child.getName());
System.out.println("Path: " + child.getAbsolutePath());
System.out.println("Is Root: " + child.isRoot());

Iterator names = child.getPropertyNames().iterator();
while(names.hasNext()){
  String name = (String)names.next();
  System.out.println("Property " + name + 
    ": " + child.getProperty(name).asString());
}
</sapia:code>
        </sapia:sect4>                
      </sapia:sect3>
      
      <sapia:sect3 title="Registry Factories">
        <p>In order to be able to access configuration properties, one has
        to acquire a <sapia:class>Registry</sapia:class> instance. That is done
        using a <sapia:class link="api/org/sapia/regis/RegistryContext.html" target="target_window">RegistryContext</sapia:class>.
        </p>
        <p>The <sapia:class>RegistryContext</sapia:class> class plays a role
        analogous to the <sapia:class>InitialContext</sapia:class> in JNDI: an
        InitialContext is given a set of properties, among which is the name of
        the underlying JNDI context factory corresponding to the desired
        JNDI implementation.</p>
        
        <p>Hence, a registry context is given the name of the <sapia:class>RegistryFactory</sapia:class>
        class to use in order to instantiate a registry (that class name must be mapped to the <code>org.sapia.regis.factory</code> property). 
        In addition, the context is given all the parameters necessary to instantiate the underlying registry; the context passes these
        parameters (in the form of a <sapia:class>java.util.Properties</sapia:class> object) to the registry 
        factory that it instantiates. Thus, the context's only use
        is to instantiate the factory and delegate to that factory instantiation of the
        registry. The following snippet illustrates what we mean:</p>
 
<sapia:code>
Properties props = new Properties();
props.setProperty(RegistryContext.FACTORY_CLASS, 
  "&lt;someClassName&gt;");
// here set other properties has needed...
RegistryContext context = new RegistryContext();
Registry regis = context.connect(props);
...
</sapia:code>
        
        <p>Now, the above is neat if you know that the underlying registry factory will always be the same. But oftentimes, that won't
        be the case. When dealing with multiple environments (developer workstation, dev, QA, prod, etc), the way configuration is
        accessed (or in other words, the type of registry applications use) will mostly be different. This is especially true
        on developer workstations, where the registry used locally in development will most preferrably be the 
        <sapia:class>LocalRegistry</sapia:class> (as compared to other environments, where the <sapia:class>RemoteRegistry</sapia:class>
        will be favored). The <sapia:class link="api/org/sapia/regis/RegistryContext.html" target="target_window">javadoc</sapia:class> of the
        <sapia:class>RegistryContext</sapia:class> class explains registry boostrapping in details, but let's say for starters
        that you can specify (as a property) a list of property resources that will be sequentially processed in order to acquire
        the properties necessary to instantiate a registry:</p>

<sapia:code>
Properties props = new Properties();
props.setProperty(RegistryContext.BOOTSRAP, 
  "${user.home}/regis/registry.properties, com/acme/conf/regis.properties");
// here set other properties has needed...
RegistryContext context = new RegistryContext();
Registry regis = context.connect(props);
...
</sapia:code>          

        <p>In the above, the registry context uses the value of the bootstrap property (interpreted as a comma-delimited list
        of resources) in order to load the properties used to initialize itself. The first resource that can be found is
        used, and the search process stops at that point. In the above example, provided that <b>no</b> <sapia:command>registry.properties</sapia:command>
        file exists under <sapia:command>${user.home}/regis/registry.properties</sapia:command> in production, the properties given last
        are used (which in this case could point to a distributed registry, shared by distributed applications). Thus, a convention in this
        case would be to have developers put a <sapia:command>registry.properties</sapia:command> file under their home directory, which would 
        then bypass the production settings.</p>


        <sapia:sect4 title="Local Registry Factory">
          <p>The <sapia:class link="api/org/sapia/regis/local/LocalRegistryFactory.html" target="target_window">LocalRegistryFactory</sapia:class> instantiates
          an in-memory registry intended for testing or non-distributed,
          embedded use. The registry supports write-operations (it creates
          <sapia:class>RWNode</sapia:class>s), but is not
          transactional - even though it creates instances of the
          <sapia:class link="api/org/sapia/regis/RWSession.html" target="target_window">RWSession</sapia:class> interface. The following code 
          shows how to instantiate an in-memory registry:
          </p>
<sapia:code>
Properties props = new Properties();
props.setProperty(RegistryContext.FACTORY_CLASS, 
  "org.sapia.regis.local.LocalRegistryFactory");
RegistryContext context = new RegistryContext();
Registry regis = context.connect(props);
RegisSession sess = regis.open();
try{
  Node root = regis.getRoot();
  ...
}finally{
  sess.close();
}
</sapia:code>

        </sapia:sect4>
         
        <sapia:sect4 title="Hibernate Registry Factory">
          <p>The <sapia:class link="api/org/sapia/regis/hibernate/HibernateRegistryFactory.html" target="target_window">HibernateRegistryFactory</sapia:class> instantiates
          a registry based on Hibernate. The registry supports write-operations (it creates
          <sapia:class>RWNode</sapia:class>s and <sapia:class>RWSessions</sapia:class>s). The following code shows
          how to instantiate a Hibernate registry:
          </p>
<sapia:code>
Properties props = new Properties();
props.setProperty(RegistryContext.FACTORY_CLASS, 
  "org.sapia.regis.hibernate.HibernateRegistryFactory");
// load the  properties...
InputStream is = 
  new FileInputStream("someDir/hibernate.properties");
props.load(is);

RegistryContext context = new RegistryContext();
Registry regis = context.connect(props);
...
</sapia:code>
          <p>Typically, client applications will make use of read-only operations. But the
          Hibernate registry supports write-operations. In this case, a <sapia:class>RWSession</sapia:class> 
          is opened, the desired operations are performed, the changes are committed/rolled back, and eventually the session is closed:</p>
          
<sapia:code>
RWSession session = (RWSession)regis.open();

try{
  RWNode rwNode = (RWNode)regis.getRoot();
  Node child = rwNode.createChild("someChild");
  session.commit();
}catch(RuntimeException e){
  session.rollback()
  throw e;
}finally{
  session.close();
}
...
</sapia:code>
          <p>Note that the Hibernate registry factory expects the following properties to be set, providing default
          values for the others:</p>
          <ul>
            <li>hibernate.dialect</li>
            <li>hibernate.connection.driver_class</li>
            <li>hibernate.connection.url</li>
            <li>hibernate.connection.username</li>
            <li>hibernate.connection.password</li>
          </ul>
          <p>In addition, the implementation uses c3p0 as a database connection pool implementation. More
          information of Hibernate's configuration properties (as well as c3p0 properties) can be found 
          on the <a target="hibernate" href="http://www.hibernate.org">Hibernate site</a>.</p>
          
          <sapia:note>
          The Hibernate registry makes use of Hibernate's second-level cache, based on EHCache.
          </sapia:note>
          
        </sapia:sect4>

        <sapia:sect4 title="Prevayler Registry Factory">
          <p>As you might guess, using a Registry instantiation by a <sapia:class link="api/org/sapia/regis/prevayler/PrevaylerRegistryFactory.html" target="prevaylerFactory">PrevaylerRegistryFactory</sapia:class>
          allows you configuration to be kept across process restarts. Using the class is straightforward, since it follows the same pattern as the previous factories (having
          a look at the javadoc should be good enough to be able to start using the Prevayler registry).
          </p>
          <p>
          The intent behind the Prevayler registry is to in fact use it in conjunction with a <a href="#registryServer">registry server</a>. This allows starting
          persistent registry nodes over the network that synchronize each other's state, and also to remotely upload configuration into these nodes. On the
          client-side, using a <a href="#cachingRegistry">caching registry</a> spares network roundtrips.
          </p>
        </sapia:sect4>

        <sapia:sect4 title="Caching Registry Factory" alias="cachingRegistry">
          <p>A <sapia:class link="api/org/sapia/regis/cache/CacheRegistryFactory.html" target="target_window">CacheRegistryFactory</sapia:class>
          is meant to wrap another <sapia:class>RegistryFactory</sapia:class> instance, and provides caching support on top of it.
          </p>
          
          <p>The cache registry thus wraps nodes returned by the underlying registry with special nodes that are in fact proxies on top
          of the original ones. A cache node caches all properties of the node that it wraps, refreshing its state at a predefined interval.</p>
          
          <p>A cache registry can be used to spare hits to the original registry. For example, if wrapping a Hibernate registry, the
          cache node spares database hits and roundtrips.</p>
       
          <p>The following illustrates how to instantiate a cache registry - which in this cas will wrap a Hibernate registry:</p>
          
<sapia:code>
Properties props = new Properties();

props.setProperty(RegistryContext.FACTORY_CLASS, 
  "org.sapia.regis.cache.CacheRegistryFactory");

// setting the refresh interval in seconds
props.setProperty(CacheRegistryFactory.REFRESH_INTERVAL, 
  "org.sapia.regis.cache.interval");

// this following property is used to indicate to the 
// CacheRegistryFactory which factory it will in turn wrap
props.setProperty(CacheRegistryFactory.FACTORY_CLASS, 
  "org.sapia.regis.hibernate.HibernateRegistryFactory");

// here set the properties expected by the 
// HibernateRegistryFactory
InputStream is =
  new FileInputStream("someDir/hibernate.properties");
props.load(is);

RegistryContext context = new RegistryContext();
Registry regis = context.connect(props);

// using the registry normally
RegisSession session = regis.open();
try{
  ...
}finally{
  session.close();
}

</sapia:code>
          <p>As can be seen. the class of the registry factory to wrap is passed as a value
          for the following property: <sapia:command>....</sapia:command>. 
          </p>
          
          <sapia:note>
            The nodes returned by a CacheRegistry do not support write-operations.
          </sapia:note>
          
       </sapia:sect4>
       
        <sapia:sect4 title="Remote Registry Factory">
          <p>The remote registry relies on Sapia's <a href="http://www.sapia-oss.org/projects/ubik">Ubik</a>
          distributed computing framework to offer a robust distributed
          configuration registry. It benefits from Ubik's fail-over and load-balancing
          features. The remote registry is composed of two parts: the client-side
          and the server-side. </p>
          
          <p>Remoting a registry involves two steps:</p>
          <ul>
            <li>Making the registry available on the network (server-side)</li>
            <li>Connecting to the remote registry (client-side)</li>
          </ul>
          
          <sapia:sect5 title="Making a Registry available on the network">
            <p>To make a registry available on the network through Ubik,
            two choice are availale:</p>
            <ul>
              <li>Export the registry as a server on a given port.</li>
              <li>Bind a the registry to Ubik's distributed JNDI.</li>
            </ul>
            
            <p>To benefit from fail-over and load-balancing, the second option
            is the way to go. But in any case, here are examples for both:</p>
            
<sapia:code>
// instantiate an exporter (passing in a Registry instance)
RegistryExporter exporter = new RegistryExporter(registry);

System.setProperty("ubik.rmi.address-pattern", "localhost");

// binding to a given port
exporter.bind(40000);

// binding to a Ubik JNDI server

Properties props = new Properties();
props.setProperty(InitialContext.PROVIDER_URL, 
             "ubik://localhost:1099/");
props.setProperty("ubik.jndi.domain", "someDomain"); 
exporter.bind("regis", props);
</sapia:code>
            <p/>
            <sapia:note>
Setting the regexp corresponding to the IP address pattern (through
the <sapia:command>ubik.rmi.address-pattern</sapia:command> system property) forces Ubik to select a 
network interface that will match the regexp, and on which it will have the 
server listen. See <a target="ubik" href="http://www.sapia-oss.org/projects/ubik/tutorial.html#bindaddr">Ubik's doc</a>
for more info.            
            </sapia:note>

            <p>In the first case, the registry is bound to the network under
            a specific port; in the second case, the regitry is bound to
            an anonymous port and its stub published to Ubik's JNDI. In that
            latter case, publishing the registry to the JNDI automatically
            makes it benefit from Ubik's fail-over and load-balancing features.
            This allows publishing multiple registries on the network, with
            each acting as a backup for the others - provided they hold identical
            configurations. The exporter makes use of Ubik's client-side JNDI
            implementation. Please see the <a target="ubik" href="http://www.sapia-oss.org/projects/ubik/naming.html">Ubik doc</a>
            for more info the above-specified JNDI-related properties.</p>
            
            <sapia:note>
              For more details, have a look at the 
              <sapia:class link="api/org/sapia/regis/remote/RegistryExporter.html">RegistryExporter</sapia:class> 
              class.
            </sapia:note>
          </sapia:sect5>
          <sapia:sect5 title="Looking Up a Remote Registry">
            <p>From a client application's point of view, looking up a remote 
            registry involves the same steps as using any other registry. In
            this case, though, a 
            <sapia:class link="api/org/sapia/regis/remote/client/RemoteRegistryFactory.html">RemoteRegistryFactory</sapia:class>
            must be used, configured with the appropriate properties. The following snippet
            shows how to connect to a remote registry bound to a specific port, and one bound
            to the JNDI, under a given name:</p>
<sapia:code>
// looking up a Registry bound to a specific host/port
Properties props = new Properties();
props.setProperty(RegistryContext.FACTORY_CLASS, 
                  RemoteRegistryFactory.class.getName());
props.setProperty(RemoteRegistryFactory.ADDRESS, "localhost");
props.setProperty(RemoteRegistryFactory.PORT, "40001");    

// looking up a Registry bound to Ubik's JNDI
Properties props = new Properties();
props.setProperty(RegistryContext.FACTORY_CLASS, 
                  RemoteRegistryFactory.class.getName());
props.setProperty(RemoteRegistryFactory.JNDI_NAME, "regis");  
props.setProperty(InitialContext.PROVIDER_URL, 
             "ubik://localhost:1099/");
props.setProperty("ubik.jndi.domain", "someDomain"); 
RegistryContext ctx = new RegistryContext(props);
Registry reg = ctx.connect();
...
</sapia:code>
            <p/>         
            <sapia:note>
              For more details, have a look at the 
              <sapia:class link="api/org/sapia/regis/remote/client/RemoteRegistryFactory.html">RemoteRegistryFactory</sapia:class> 
              class.
            </sapia:note>
               
          </sapia:sect5>
        </sapia:sect4>      
        
      </sapia:sect3>
      
    </sapia:sect2>
    
    <sapia:sect2 title="Property Structure">
      <sect-desc>
      Regis provides different mechanisms to allow for reusing properties.
      </sect-desc>
      <sapia:sect3 title="Inheritance">
        <p>A registry is a hierarchy of nodes, each node having a parent (except
        the root node) and, potentially, child nodes. Property resolution in
        Regis can rely on node inheritance in order to retrieve properties that
        are not present at the level of a given node, but can be found at the
        one of an ancestor node.</p>
        
        <p>By default, node inheritance is not enabled. This means that by default,
        the <sapia:command>isInheritsParent()</sapia:command> method of the 
        <sapia:class>Node</sapia:class> interface returns <sapia:command>false</sapia:command>.
        In order to enable node inheritance, the "inheritsParent" flag has to be set
        to <sapia:command>true</sapia:command> - this can be done when configuring nodes
        in a registry, in will be shown in the <a href="#configuration">Configuration</a> 
        section further below.</p>
        
        <p>Property resolution, in the context of node inheritance, works as follows:
        the required property is looked up at the current node; if it is found, it is 
        returned; if not and node inheritance is enabled, the ancestor is searched,
        and so on until a matching property is found - or until all relevant
        nodes have been searched and no property could be found.</p>
        
      </sapia:sect3>
      <sapia:sect3 title="Links">
        <p>Node inheritance might not prove sufficient (or desired) in complex 
        configuration cases: sometimes it can have undesired side effects, or
        sometimes it might be relevant to have given properties be "present" at
        the level of a given node without that node being a descendant of the
        node from which the properties originate.</p>
        
        <p>In that case, node linking can be used. In fact, node linking was
        introduced to provide the behavior of node inheritance, without the
        ancestor/descendant relationship. </p>        
        
        <p>A link is created by associating an existing node to another. 
        In this case, the relationship is not a composition, but very much
        an association: the associated node is not "bound" to the lifecycle
        of the one to which it is linked, neither is it consider a child
        of that node.</p>
        
        <sapia:sect4 title="Prepended Links">
          <p>There are two types of links: prepended links and appended links. 
          In the context of property resolution, prepended links consist of 
          nodes that are searched prior to the current node, when looking up
          a given property. More precisely, prepended links act has if they
          were overriding the current node.
          </p>
          
          <p>When a node has a prepended link to another node, or to multiple other nodes,
          property resolution works as follows: all such links (nodes) are searched
          for the required property, in the order in which they were added. If the
          property could not be found, then the matching property at the current node is
          returned - if it exists.</p>          
        </sapia:sect4>
        
        <sapia:sect4 title="Appended Links">
          <p>Appended links have a more intuitive behavior: such links do not override
          the node to which they are added, but are rather overriden by it. Therefore,
          when resolving properties, the following happens: the desired property
          is searched at the current node. If it is found, it is returned;
          otherwise, all appended links (nodes) are searched, in the order in 
          which they were added, until the desired property could be found, or
          until none could be found.</p>          
        </sapia:sect4>       
      </sapia:sect3>      
      <sapia:sect3 title="Includes">
        <p>Includes correspond to nodes that are "physically" added to other nodes,
        yet not as children. Included nodes only appear to be present as child nodes, 
        because in fact the node to which they are added is not set as their parent.
        This means that included nodes have another parent, but seem to be physically
        contained by the node in which they are included.</p>
        
        <p>More precisely, included nodes have the following characteristices</p>
        
        <ul>
          <li>A node will be accessible by its name under the node to
          which it is included. This means that if node B is included into node A,
          and that the name of node B is "nodeB", the following will return
          node B: <sapia:command>A.getChild("nodeB")</sapia:command>. The
          same explanation applies to path access. the following will
          return node B (provided node A' name is "nodeA", and lookup is
          done from the root node of the registry): 
          <sapia:command>root.getChild(Path.parse("nodeA/nodeB"))</sapia:command>.</li>

          <li>A node that is included under another node will be returned in
          that node's child collection, when the <sapia:command>getChildren()</sapia:command>
          method is called. Do not be mistaken though: included nodes do not have their
          including node as their parent. In fact, a node can be included in multiple
          other nodes...</li>
        </ul>
        
       <p>Property resolution, in the context of included nodes, does not work as 
       in other types of relationships. In fact, property resolution at a given
       node does not "cascade" to included nodes. Included nodes have simply been
       introduced in order to allow reusing nodes that have been previously
       defined in the registry: imagine that you defined different sets of user
       accounts (each account corresponding to a node), for the different department
       in your organization: helpdesk, managers, sales, etc. You would have the 
       "helpdesk", "managers", "sales" nodes, and under each one, the accounts (nodes)
       that correspond to each of these groups. Now, imagine that you have defined
       application nodes: "accounting", "callcenter", "crm", and you want to add
       specific accounts or groups of accounts under each of these nodes, to reflect
       who is given access to what. In this case, you do not want to redefine, under
       the different application nodes, the accounts or groups of accounts that 
       you've already set up. You rather want to reuse them.
       </p>
       
       <p>That's where includes come in: you include, to each application node, the
       nodes corresponding to the groups/users that have access to the that
       application. And then, using Regis' node lookup API (by name, by path
       by query, getting the children), you can build your security layer, based
       on the account/application structure you have defined in the registry.</p>  
      </sapia:sect3>      
      
      <sapia:sect3 title="Mixing Inheritance and Links">
        <p>Mutiple node reuse patterns can be implemented at once: inheritance,
        prepended links, appended links. Property resolution globally works
        as follows:</p>
        
        <ul>
          <li>Prepended links of the current node are searched. If a property
          could be found, it is returned.</li>
          <li>If no property could be found, the current node is is searched 
          (a match is attempted on its own properties). If a property could be
          found, it is returned.</li>
          <li>Otherwise, if the current node has its inheritance enabled, the parent is searched
          (respecting this algorithm). If a property could be found, it is returned.</li> 
          <li>If no property could be found, the appended links are searched. If a property could be
          found, it is returned.</li>         
          <li>In the end, if no property could be found, a null property is returned.</li>
        </ul>
      </sapia:sect3>
    </sapia:sect2>
    
    <sapia:sect2 title="Variable Interpolation">
      <p>The node interface supports variable interpolation. This allows using property
      values as variables in other property values.</p>
      <sapia:sect3 title="How it Works">
      <p>Imagine for example that you set up a registry with JDBC connection
      parameters to different databases; each database connection configuration corresponds
      to a node, as illustrated conceptually below:</p>
      
<sapia:code>
databases
  db1
    username: fu
    password: bar
    url: jdbc:hsqldb:mem:database1
    driver: org.hsqldb.jdbcDriver
  db2
    username: sna
    password: fu
    url: jdbc:hsqldb:mem:database2
    driver: org.hsqldb.jdbcDriver
 ...
</sapia:code>
     <p>Now, we observe two things here: both connection will share the
     same driver. In addition, both connections will share the same database
     server, but not the same database in that server. Taking that into
     consideration, you opt to redesign your configuration as follows (remember
     that the example below does not correspond to the Regis configuration
     format, but is strictly meant to better illustrate the variable interpolation
     feature):</p>
          
<sapia:code>
databases
  common
    driver:org.hsqldb.jdbcDriver
    baseUrl:jdbc:hsqldb:mem:
  connections 
    db1
      username: foo
      password: bar
      url: ${baseUrl}database1
      --
      append link: common
    db2
      username: sna
      password: fu
      url: ${baseUrl}database2
      --
      append link: common
    ...
</sapia:code>     
      <p>
      There are three things to notice:
      </p>
      <ol>
        <li>The configuration has been restructured in order to profit from
        node/property reuse and variable interpolation: since the driver is the same,
        and the database server is the same, a "common" node has been defined, which
        holds the properties (or parts of the propertries) that are common to all
        database nodes. Then the common node is appended as a link to each
        database node.</li>
        <li>The driver property has been removed from each database node,
        since from now on each will "inherit" that property from the common node, by virtue
        of linking.</li>
        <li>The most important part, that we want to illustrate in this example:
        the url property value has been rewritten to embed a variable (to be
        understood as such by Regis, it must respect the <sapia:command>${var_name}</sapia:command>
        notation). That variable will be resolved at runtime; in such cases, Regis expects variables
        to correspond to the name of existing properties. When performing variable interpolation,
        <b>Regis employs the same algorithm as the one defined in the previous section,
        with regards to node inheritance and linking</b>. If no value could be found for the
        given variable, then it is simply not interpolated; no error is generated,
        and in the above case, the value of the url property would be "${baseUrl}/database2".
        </li>
      </ol>
      </sapia:sect3>
      <sapia:sect3 title="When it is Applied">
        <p>Interpolation is not performed at registry configuration time. It rather
        occurs on a per-node basis, at runtime. More precisely, it occurs when:</p>
        
        <ul>
          <li>One of the <sapia:command>getProperties()</sapia:command> method is called
          on a Node instance.</li>
          <li>One of the <sapia:command>renderProperty()</sapia:command> method is called
          on a Node instance.</li>          
        </ul>
        
      </sapia:sect3>
    </sapia:sect2>
   
    <sapia:sect2 title="XML Configuration" alias="configuration">
      <p>Regis supports a convenient configuraton format that can be used to create/update/delete 
      nodes in a registry. XML fits very well with Regis' hierarchical design. The following
      (used as part of Regis' test suite) consists of a configuration that creates a node
      hierarchy in a registry (note that variant of the following format is 
      possible - see <a href="#alternateProp">further below</a> for more info):</p>
<sapia:code><![CDATA[<registry>
  <node name="databases">
    <node name="000">
      <property name="username" value="jsmith" />
      <property name="password" value="foo123" />      
      <property name="url"      value="jdbc://saturn:5432/" />            
    </node>
    <node name="001" id="db1">
      <property name="username" value="stiger" />
      <property name="password" value="bar123" />      
      <property name="url"      value="jdbc://pluto:5432/" />                
    </node>    
    <node name="002">
      <link ref="db1" />
      <property name="url"      value="jdbc://mercury:5432/" />                      
    </node>        
  </node>
  <node name="users">
    <node name="backoffice" id="bo">
      <node name="account1">
        <property name="username"  value="cbrown" />
        <property name="firstName" value="Charlie" />        
        <property name="lastName"  value="Brown" />                
        <property name="password"  value="lupus9890!" />        
      </node>
      <node name="account2">
        <property name="username"  value="dmenace" />
        <property name="firstName" value="Dennis" />        
        <property name="lastName"  value="Menace" />                
        <property name="password"  value="canis$2677" />        
      </node>      
    </node>
    <node name="management">
      <node name="account3" id="act3">
        <property name="username"  value="bgates" />
        <property name="firstName" value="Bill" />        
        <property name="lastName"  value="Gates" />                
        <property name="password"  value="gates1980!" />        
      </node>
    </node>    
    <node name="support">
      <include ref="bo@" />
      <include ref="act3" />
    </node>
  </node>
</registry>]]></sapia:code>
      
      <sapia:sect3 title="Basics">
      <p>
       As can seen, the Regis XML configuration format directly reflects
       the structure of a registry:
      </p>
      <ul>
        <li>A configuration takes the <sapia:command>registry</sapia:command>
         root element. Such an element contains one to many 
         <sapia:command>node</sapia:command> elements, that each correspond
         to a Node under the registry's root Node.</li>
         
        <li>A <sapia:command>node</sapia:command> element can in turn contain
        zero to many <sapia:command>node</sapia:command> elements,
        as well as zero to many <sapia:command>property</sapia:command>,
        <sapia:command>link</sapia:command> and <sapia:command>include</sapia:command> elements.
        Each <sapia:command>node</sapia:command> element takes a mandatory 
        <sapia:command>name</sapia:command> (corresponding to the Node's name). Optionally,
        a <sapia:command>node</sapia:command> element can take an <sapia:command>id</sapia:command>
        attribute, meant to identify that node uniquely within the configuration, so that
        it can be referred to later on in the XML (the <sapia:command>id</sapia:command> attribute
        is not taken into account when the configuration is actually loaded into the registry).
        </li>
        
        <li>In addition, as an alternative to the <sapia:command>id</sapia:command> attribute when refering to another node, 
        the full path of the referred node under the root can be given (this can be useful when loading configuration from multiple 
        interrelated files, or when loading configuration in a registry that already has nodes needing to be referred to):<p/>   
<sapia:code><![CDATA[<registry>
  ...
  <node>
    <node name="support">
      <include path="users/backoffice@" />
      <include path="management/account" />
    </node>
  </node>
</registry>]]></sapia:code>        
        <p/></li>
        
        <li>A <sapia:command>property</sapia:command> element takes mandatory
        <sapia:command>name</sapia:command> and <sapia:command>value</sapia:command>,
        indicating the name and value of the corresponding property.
        </li>                      
        
        <li>A <sapia:command>link</sapia:command> element corresponds to a prepended
        or appended link. It optionally takes a <sapia:command>type</sapia:command>
        attribute, whose value may be <sapia:command>prepend</sapia:command> or
        <sapia:command>append</sapia:command>, depending on the desired type
        of link (if the attribute is not specified, an appended link is presumed). 
        In addition, the element takes a mandatory <sapia:command>ref</sapia:command> 
        attribute, whose value corresponds to the <sapia:command>id</sapia:command> of 
        an existing <sapia:command>node</sapia:command> element. When instantiating 
        the objects corresponding to the configuration, this indicates to the 
        configuration loader that a node should be added (has a link) at that specific point in the
        hierarchy.
        </li>
        
        <li>An <sapia:command>include</sapia:command> element corresponds to a node
        that is to be included under the corresponding current node. Similarly
        to the <sapia:command>link</sapia:command>, its takes a mandatory <sapia:command>ref</sapia:command> 
        attribute, whose value, this time, corresponds to the node whose <sapia:command>id</sapia:command> 
        matches the given value and that is to be included, or to the node whose child nodes should be included.
        Indeed, the value of the <sapia:command>ref</sapia:command> element can be of the form <i>node_id</i>
        or <i>node_id@</i> - with the <i>@</i> character being interpreted in a special way be Regis. 
        In the former case, the node corresponding to the given identifier is included;
        in the latter case, all child nodes of the node whose identifier is given will be included (more concretely,
        the nodes the child nodes will be added to the target node one at a time, as if they would be added one
        by on individually, through multiple includes).
        </li>
        
      </ul>
      </sapia:sect3>
      <sapia:sect3 title="Resource/File Resolution">
        <p>All URIs that point to configuration files and are processed by Regis are searched using the 
	same resolution logic:</p>

        <ol>
          <li>Search under the "current directory" (corresponding to the <sapia:command>user.dir</sapia:command> system property).</li>
          <li>Search the resource as a URL (if it starts with a scheme handled by the JDK - http, etc.).</li>
          <li>Search in the application's classpath.</li>
        </ol>

	<p>Search stops as soon as a resource is found. If all search steps have completed without a resource
	being found, an exception is thrown.</p>

      </sapia:sect3>
      <sapia:sect3 title="Operations">
      <p>
        The configuration allows specifying which operation should be performed,
        on a per-node basis. This is done by setting the <sapia:command>operation</sapia:command>
        attribute on the appropriate <sapia:command>node</sapia:command> element. The
        value of that attribute can be one of the following:
        
        <ul>
          <li><sapia:command>create</sapia:command>: this will trigger the creation
          of a new node, completely overwriting the current corresponding node in
          the hierarchy, if any, and <b>deleting all child nodes of the current one</b>.</li>
          
          <li><sapia:command>update</sapia:command>: this will indicate that the
          current corresponding node (if any) is to be kept if it exists, as well
          as its properties, child nodes, links, and includes. In that case the
          node configuration is simply "added" to the current node. If no current
          node exists, then the result amounts to the one of a create.</li>
          
          <li><sapia:command>update-overwrite</sapia:command>: this will indicate that the
          current corresponding node (if any) is to be kept if it exists (as well
          as links, children and includes), but its properties deleted prior to the
          node configuration being "added" to the current node. If no current
          node exists, then the result amounts to the one of a create. This is convenient
          when you want to delete "old" properties in order to keep only the ones
          that are currently needed.</li>          
          
          <li><sapia:command>delete</sapia:command>: this indicates that the
          matching node is to be deleted - as well as its children.</li>          
        </ul>
        
        <sapia:note>
        By default, node operations are done in <b>update</b> mode, meaning that if no
        <sapia:command>operation</sapia:command> attribute is specified on a
        given node, update is presumed.
        </sapia:note>
      </p>
      <p>
      The configuration below is given as an example of operations on nodes:
      </p>
<sapia:code><![CDATA[<registry>
  <node name="databases">
    <node name="000" operation="delete" />
    <node name="001" operation="update">
      <property name="username" value="mrspock" />
    </node>    
  </node>
  <node name="users">
    <node name="backoffice">
      <node name="account1">
        <node name="address">
          <property name="street"  value="1234 Sesame" />
          <property name="city"    value="New York" />        
          <property name="state"   value="NY" />                
          <property name="country" value="US" />                
        </node>
      </node>
    </node>
  </node>
</registry>]]></sapia:code>
      <p>
      Note that in addition, for convenience, a default operation can be specidied, as
      an attribute of the <sapia:command>registry</sapia:command> element: </p>

<sapia:code><![CDATA[<registry defaultOperation="update-overwrite">
  <node name="databases">
    <node name="000" operation="delete" />
    <node name="001" operation="update">
      <property name="username" value="mrspock" />
    </node>    
  </node>
</registry>]]></sapia:code>      
      
      <p>In such a case, that default operation is "inherited" by all 
      <sapia:command>node</sapia:command> elements, unless it is overridded at the node level, 
      by specifying the <sapia:command>operation</sapia:command> attribute.
      </p>

      </sapia:sect3>
      <sapia:sect3 title="Loading">
        <p>In order to load a configuration into a registry, that registry must
        support read-write operations. Loading a configuration involves
        using a <sapia:class link="api/org/sapia/regis/loader/RegistryConfigLoader.html">RegistryConfigLoader</sapia:class>:</p>

<sapia:code>
RWSession session = (RWSession)reg.open();
session.begin();    
RWNode node = (RWNode)reg.getRoot();
RegistryConfigLoader loader = new RegistryConfigLoader(node);
loader.load(new File("path/to/config.xml"));
session.commit();
session.close();
</sapia:code>

        <p>Note that loading a configuration "in" the root node of the registry is not mandatory.
        One can load a configuration at any existing node in a hierarchy:</p>
<sapia:code>
RWSession session = (RWSession)reg.open();
session.begin();    
RWNode node = (RWNode)reg.getRoot().getChild("child1/child2");
RegistryConfigLoader loader = new RegistryConfigLoader(node);
loader.load(new File("path/to/config.xml"));
session.commit();
session.close();
</sapia:code>

        <p>The node that is passed to the loader will be considered the "configuration root",
        but is not necessarily the root of the registry.</p>
      </sapia:sect3>      
      
      <sapia:sect3 title="Static Interpolation">
        <p>The configuration supports variables that are interpolated only once, when the configuration
        file is actually loaded - and prior to be parsed as an XML document. Such variables
        must follow the <sapia:command>$[variable_name]</sapia:command> notation. The example below
        demonstrates how this is done:</p>
      
<sapia:code><![CDATA[<registry defaultOperation="update-overwrite">
  <node name="transactionService">
    <property name="jndiName" value="services/transaction" />
    <property name="domain"   value="$[ubik.jndi.domain]" />
  </node>
</registry>]]></sapia:code>            

        <p>Expected variables must be passed when loading the configuration, or as
        system properties:</p>

<sapia:code>
RWSession session = (RWSession)reg.open();
session.begin();    
RWNode node = (RWNode)reg.getRoot();
RegistryConfigLoader loader = new RegistryConfigLoader(node);
Map vars = new HashMap();
vars.put("ubik.jndi.domain", "mercury");
loader.load(new File("path/to/config.xml"), vars);
session.commit();
session.close();
</sapia:code>

				<p>If given variables cannot be resolved using the given map of values
				passed in, then the system properties are looked up.</p>
				
				<sapia:note>Keep in mind that static interpolation occurs upon loading the XML
				configuration, and prior to parse the XML. Therefore, static variables are
				not resolved using links or inheritance. Upon being resolved, static variables
				appear as being orginally part of the XML configuration.</sapia:note>

      </sapia:sect3>
      <sapia:sect3 title="Static Inclusion">
        <p>Static includes allow including the content of a given Regis configuration resource into another.
	The snippets below illustrate how this is done. First, a parent file specifies the resource to include:
        </p>
<sapia:code><![CDATA[<registry defaultOperation="update-overwrite">
  <node name="datasources">
   <staticInclude uri="org/acme/app/jcbc.regis.xml">
     <param name="datasource" value="orders" />
     <param name="driver" value="org.hsqldb.jdbcDriver" />
     <param name="username" value="sa" />
     <param name="password" value="" />
     <param name="url" value="jdbc:hsqldb:hsql://localhost/orders" />
   </staticInclude>
   <staticInclude uri="org/acme/app/jcbc.regis.xml">
     <param name="datasource" value="inventory" />
     <param name="driver" value="org.hsqldb.jdbcDriver" />
     <param name="username" value="sa" />
     <param name="password" value="" />
     <param name="url" value="jdbc:hsqldb:hsql://localhost/inventory" />
   </staticInclude>
  </node>
</registry>]]></sapia:code>            
        <p>An the included resource would go as follows:</p>

<sapia:code><![CDATA[<node name="$[name]">
  <driver>$[driver]</driver>
  <username>$[username]</username>
  <password>$[password]</password>
  <baseUrl>$[url]</baseUrl>
</node>]]></sapia:code>            

        <p>As the snippets above illustrate, a <sapia:command>staticInclude</sapia:command> tag allows including a configuration resource
        as some sort of template, to which variables can be passed (and which are substituted at load time with the proper values). This
        allows reusing a given configuration resource across different contexts (i.e.: with different values).</p>

        <sapia:note>Note that the included resource must evaluate to a single configuration object a load time (a property, a node, etc.). In
	other terms, it means that the included file must correspond to a single XML element corresponding to a configuration object known
	to Regis.</sapia:note>

      </sapia:sect3>
      <sapia:sect3 title="Parameter Assignment">
        <p>As was shown in the previous sections, parameters can be based to the configuration loader
        in the form of a <sapia:class>Map</sapia:class> instance. These parameters can then
        be recuperated in the configuration and assigned to nodes, properties, etc. For example:
        </p>
<sapia:code><![CDATA[<registry>
  <node name="myapp">
    <node name="cache">
      <property name="baseDir">
        <value><paramRef name="cacheBaseDir" default="./cache" /></value>
      </property>
    </node>    
  </node>
</registry>]]></sapia:code>        
        <p>As the example demonstrates, a <sapia:command>paramRef</sapia:command> element
        allows assigning a user-defined value to any "object" in the configuration. In
        this case, the only requirement is to replace attribute notation with element
        notation (in the above, the <sapia:command>value</sapia:command> attribute 
        that is normally used on the <sapia:command>property</sapia:command> is replaced
        by a corresponding <sapia:command>value</sapia:command> element).</p>
        
        <p>The <sapia:command>paramRef</sapia:command> takes the following attributes:</p>
        
        <ul>
          <li><b>name</b>: the name of an existing parameter or system property.</li>
          <li><b>default</b>: a default value to be used, if none could be found for the specified name.</li>          
        </ul>
        
        <p>Not that if no default value is given and no value could be found for the specified name,
        an exception is thrown and configuration loading is aborted.</p>
        
      </sapia:sect3>      
      <sapia:sect3 title="Conditional Loading">
        <p>The configuration in addition supports conditional instructions allowing
        to load given parts of the configuration, based on user-specified parameters or
        given system properties. The instructions are processed only at configuration loading time 
        (i.e.: they are not kept in the registry, and do not impact post-configuration registry
        operations, such as node and property lookups).</p>
        
        <sapia:sect4 title="If">
          <p>The <sapia:command>if</sapia:command> element allows conditionally
          processing a single nested element, based on a user-defined parameter or system
          property:</p>
      
<sapia:code><![CDATA[<registry>
  <if param="environment" value="dev">
    <node name="someNode">
      <property name="foo" value="bar" />
    </node>
  </if>
</registry>]]></sapia:code>            
          <p>The above node will be created in the registry only if the
          "environment" parameter value equals "dev". The <sapia:command>if</sapia:command>
          element takes the following attributes:</p>

          <ul>
            <li><b>param</b>: the name of a user-defined parameter or system property to match</li>
            <li><b>value</b>: a value or comma-delimited list of values to test for equality - if a list is
            specified, the condition evaluates to true on the first value that matches.</li>
          </ul>
          
          <p>If no value is specified, the condition evaluates to true if a value exists (is not null)
          for the given parameter/system property.</p>
          
          <p>Note that condition evaluation can also be done on a pattern: condition evaluation will be based
          on a value being matched, rather than on equality:</p>          
          
<sapia:code><![CDATA[<registry>
  <if param="domain" value="prod-asia-*">
    <node name="someNode">
      ...
    </node>
  </if>
  <if param="domain" value="prod-americas-*">
    <node name="someNode">
      ...
    </node>
  </if>  
</registry>]]></sapia:code>                      

		  <p>Imagine in the above example that a configuration is used by servers that are grouped by domain, geographically, where a
		  given continent may be served by multiple server clusters (or domains). In this case, configuration may vary on a per-continent
		  basis, and configuring nodes on a per-domain basis may be too tedious. To be more precise, imagine that asia is served by the
		  following domains: prod-asia-01, prod-asia-02, etc. Then, all these domains could share common configuration nodes, without
		  having to repeat the nodes for each domain. This feat, as illustrated above, is accomplished through pattern matching.</p>
		  
          <sapia:note>The <sapia:command>matches</sapia:command> attribute can support a comma-delimited list of patterns. The condition
          evaluates to true on the first pattern that matches.</sapia:note>		  
        </sapia:sect4>
        
        <sapia:sect4 title="Unless">
          <p>The <sapia:command>unless</sapia:command> element allows conditionally
          processing a single nested element, based on a user-defined parameter or system
          property:</p>
      
<sapia:code><![CDATA[<registry>
  <unless param="environment" value="dev">
    <node name="someNode">
      <property name="foo" value="bar" />
    </node>
  </unless>
</registry>]]></sapia:code>            
          <p>The above node will be created in the registry only if the
          "environment" parameter value <b>does not</b> equal "dev", or is <b>not</b> defined. Therefore, 
          the <sapia:command>unless</sapia:command> element is the "opposite" of the <sapia:command>if</sapia:command>
          element. It takes the following attributes:</p>

          <ul>
            <li><b>param</b>: the name of a user-defined parameter or system property to match</li>
            <li><b>value</b>: a value or comma-delimited list of values to test for equality - if a list is
            specified, the condition evaluates to false on the first value that matches.</li>
          </ul>
          
          <p>If no value is specified, the condition evaluates to false if a value exists (is not null)
          for the given parameter/system property.</p>
          
          <sapia:note>This element also supports a <sapia:command>matches</sapia:command> attribute, for pattern matching, 
          as explained for the <sapia:command>if</sapia:command> element in the previous section.</sapia:note>
          
        </sapia:sect4>        
        
        <sapia:sect4 title="Choose">
          <p>The <sapia:command>choose</sapia:command> element is similar to the
          <sapia:command>if</sapia:command> element, except that it allows testing for
          multiple conditions, and "branching" on the first condition that is verified:</p>
      
<sapia:code><![CDATA[<registry>
  <choose>
    <when param="environment" value="dev">
      <node name="someNode">
        <property name="foo" value="bar" />
      </node>
    </when>
    <when param="environment" value="prod">
      <node name="someNode">
        <property name="sna" value="fu" />
      </node>
    </when>    
    <otherwise>
      <node name="someNode">
        <property name="fu" value="manchu" />
      </node>    
    </otherwise>
  </choose>
</registry>]]></sapia:code>            

          <p>The <sapia:command>choose</sapia:command> element takes one to many <sapia:command>when</sapia:command>
          elements, and an optional <sapia:command>otherwise</sapia:command> element. The <sapia:command>when</sapia:command>
          element takes the following attributes:</p>

          <ul>
            <li><b>param</b>: the name of a user-defined parameter or system property to match</li>
            <li><b>value</b>: a value or comma-delimited list of values to test for equality - if a list is
            specified, the condition evaluates to true on the first value that matches.</li>
          </ul>
          
          <p>If no value is specified, the condition evaluates to true if a value exists (is not null)
          for the given parameter/system property.</p>
          
          <p>For its part, the The <sapia:command>otherwise</sapia:command> element takes no attributes, and is meant as 
          a catch all, provided no "when" condition is satisfied.</p>
          
          <sapia:note>This element also supports a <sapia:command>matches</sapia:command> attribute, for pattern matching, 
          as explained for the <sapia:command>if</sapia:command> element in a previous section.</sapia:note>
          
        </sapia:sect4>        
      </sapia:sect3>

      <sapia:sect3 title="Alternate Property Notation" alias="alternateProp">
        <p>Regis support an alternate way of defining node properties in the XML configuration. Instead of defining
        the <sapia:command>property</sapia:command> element with the <sapia:command>name</sapia:command> and
        <sapia:command>value</sapia:command> attributes, one could define a custom element with the element's name being
        the name of the property and the element's content being the value of the property. As an example, the
        following defines two nodes with the same properties:
        </p>

<sapia:code><![CDATA[<registry>
  <node name="databases">
    <node name="000">
      <property name="username" value="jsmith" />
      <property name="password" value="foo123" />      
      <property name="url"      value="jdbc://saturn:5432/" />            
    </node>
    <node name="000-custom">
      <username>jsmith</username>
      <password>foo123</password>
      <url>jdbc://saturn:5432/</url>
    </node>
  </node>
</registry>]]></sapia:code>            

        <p>The alternate property notation is supported in order to offer a less verbose 
        configuration format. However, the custom property definition will only work under the following circumstances:</p>

        <ul>
          <li><b>inside a node</b>: the custom element will be recognized as a property only when nested in a node element.</li>
          <li><b>no attributes</b>: the custom element must not have any attributes.</li>
          <li><b>content as value</b>: the value of the custom property must be the content of the element.</li>
          <li><b>no reserved word</b>: the custom element name must not match any reserved element name of Regis.</li>
          <li><b>no 'name' property</b>: the custom element name cannot be 'name' otherwise it can conflits with the name
          of the parent's node (in such a case use an explicit property element).</li>
        </ul>
      </sapia:sect3>
    </sapia:sect2>
    
    <sapia:sect2 title="Programmatic Configuration">
      <p>In order to be able to programmatically configure a registry, you
      need an implementation that supports write-operations. In such a case,
      you must cast your nodes to <sapia:class>RWNode</sapia:class>s,
      which gives you access to write-methods. Of course, all operations
      that modify the state of a registry must be done in a transaction.
      Transaction demarcation is available by casting your session
      to a <sapia:class>RWSession</sapia:class>.</p>
    </sapia:sect2>
    
    <sapia:sect2 title="Configuration Beans">
      <p>Configuration beans consist a nifty feature that allows wrapping <sapia:class>Node</sapia:class>
      instances in implementation of user-defined interfaces. Here are the steps involved:</p>
      
      <ul>
        <li>Design a Java interface that will act as your configuration interface. The interface
        must have getter methods that will match the corresponding property on the node that
        you want to create a proxy over.</li>
        <li>Design your configuration according to your interface - conversely, the configuration
        could be designed first, and the Java interface designed based on that configuration.</li>
        <li>Use the <sapia:class link="api/org/sapia/regis/bean/BeanFactory.html">BeanFactory</sapia:class>
        class to create an implementation of your Java interface "over" the configuration node that you target.</li>
      </ul>
      <sapia:sect3 title="Define a Java interface">
<sapia:code>
public interface SessionManagerConf{

  public long getIdleTimeout();
  
  public File getPersistenceDir();
  
}
</sapia:code>
      </sapia:sect3>
      
      <sapia:sect3 title="Define the Configuration">
<sapia:code><![CDATA[<registry>
  <node name="sessionManager">
    <property name="idleTimeout"     value="500000" />
    <property name="persistenceDir"  value=".sessions">
  </node>
</registry>]]></sapia:code>
      </sapia:sect3>      
      
      <sapia:sect3 title="Create an Instance of the Configuration Interface">
<sapia:code>
  ...
  Node node = registry.getRoot().getChild("sessionManager");
  SessionManagerConf conf = (SessionManagerConf)
  BeanFactory.newInstance(node, SessionManagerConf.class);
 ...
</sapia:code>
      <p>When creating the interface instance, Regis performs runtime checks to
      make sure that <b>a)</b> all getter methods have an existing, corresponding
      property; <b>b)</b> properties can be converted to the return type of their
      corresponding getter method.</p>
      
      <p>
      Supported return types for getter methods consist of primitive types
      (boolean, int, long, float, double) as well as <sapia:class>java.lang.String</sapia:class> and
      <sapia:class>java.io.File</sapia:class>.
      </p>

      </sapia:sect3>      

      <sapia:sect3 title="Using the Instance">
      <p>Keep in mind that every time a getter method is called on a configuration bean,
      a <sapia:class>RegisSession</sapia:class> is internally created (and closed after use,
      of course). This is hidden from the application and occurs within the dynamic
      proxy:</p>
<sapia:code>
  ...
  long    timeout    = conf.getTimeout();
  boolean persistent = conf.getPersistent();  
 ...
</sapia:code>

      <p>In order to optimize session usage you can use the 
      <sapia:class link="api/org/sapia/regis/SessionUtil.html">SessionUtil</sapia:class>
      class, like so:</p>
<sapia:code>
  ...
  SessionUtil.createSessionFor(conf);
  try{
    long    timeout    = conf.getTimeout();
    boolean persistent = conf.getPersistent();  
	...
  }finally{
    SessionUtil.close();
  }
</sapia:code>      
      <p/>
      <sapia:note>The above optimization is most important in conjunction with the Hibernate registry.</sapia:note>
      </sapia:sect3>            
      
    </sapia:sect2>
    
    <sapia:sect2 title="Registry Server" alias="registryServer">
      <p>
      	Regis comes with a registry server that embeds a <sapia:class link="api/org/sapia/regis/remote/RegistryExporter.html">RegistryExporter</sapia:class> class.
      	The javadoc of the <sapia:class link="api/org/sapia/regis/remote/RegistryServer.html">RegistryServer</sapia:class> class provides all details 
      	nessary to configure a server instance.
      </p>
      <p>
        The server can be started using the <sapia:command>regis.sh</sapia:command> script (or <sapia:command>regis.bat</sapia:command> under Windows)
        unde the <sapia:command>bin</sapia:command> directory of the Regis distribution. The argument of the script is expected to be the path
        to the Java properties file to use to initialize and start the server.
      </p>
      <p>For starters, let's just mention the features of the registry server:
        <ul>
          <li>Relies on Ubik for remoting.</li>
          <li>Allows remotely uploading configuration files.</li>          
          <li>Multiple registry servers can work in peer-to-peer mode.</li>                    
        </ul>
      </p>
    </sapia:sect2>    
    
    <sapia:sect2 title="Ant Tasks">
    
      <sapia:sect3 title="Configuration Upload"> 
        <p>
         An Ant task is provided to allow uploading configuration files into
         a registry server (see the <sapia:class link="api/org/sapia/regis/ant/RegistryTask.html">javadoc</sapia:class>
         for more information). The example below demonstrates the task's usage (the registry
         server is presumed to be published in Ubik's JNDI server):
        </p>
  <sapia:code><![CDATA[<!-- declaring the taskdef -->
  <taskdef classname="org.sapia.regis.remote.ant.RegistryTask"
    name="updateRegistry">  	
    <classpath>
      <fileset dir="${lib.dir}">
        <include name="**/*.jar"/>
      </fileset>      	      	
    </classpath>
   </taskdef>
      
  <!-- invoking the task -->
  <updateRegistry 
    jndiName="regis" 
    username="regis"
    password="secret"
    nodePath="myapp/database"
    url="ubik://192.168.0.103:1099" 
    config="etc/configDb.xml">
  </updateRegistry>]]></sapia:code>      
      </sapia:sect3>
    
      <sapia:sect3 title="Configuration Testing"> 
        <p>
         Regis provides an Ant task allowing to test a configuration prior to loading it into
         a registry (see the <sapia:class link="api/org/sapia/regis/ant/CheckConfigTask.html">javadoc</sapia:class>
         for more information). The example below illustrates how to use the task:
        </p>
  <sapia:code><![CDATA[<!-- declaring the taskdef -->
  <taskdef classname="org.sapia.regis.remote.ant.CheckConfigTask"
    name="checkConfig">  	
    <classpath>
      <fileset dir="${lib.dir}">
        <include name="**/*.jar"/>
      </fileset>      	      	
    </classpath>
   </taskdef>
      
  <!-- invoking the task -->
  <checkConfig 
    properties="conf/regis.properties"> 
    
    <checkNode path="acme/app/databases">
      <checkProperty name="url" value="jdbc:postgresql://acme/database" />
    </checkNode>
    <checkNode path="acme/app/users/charliebrown">
      <checkProperty name="username" value="cbrown" />
      <checkProperty name="password" value="foobar1234!" />
      
      <!-- checking sub-node of parent -->
      <checkNode path="permissions">
        <checkProperty name="read"    value="true" />
        <checkProperty name="write"   value="false" />
        <checkProperty name="execute" value="false" />
      </checkNode>    
    </checkNode>
    
  </checkConfig>]]></sapia:code>      
      </sapia:sect3>
    </sapia:sect2>
    
    <sapia:sect2 title="Code Generation">
       <sect-desc>
         <p>
          Loosely-typed configuration may become a pain when dealing with a statically-typed language such as Java. In order
          to bridge the gap between the loose, tree-based configuration model of Regis and the static nature of Java, a code generation
          facility has been added to the framework. Basically, it generates classes based on the configuration contained in a Registry.
         </p>
       </sect-desc>
       
       <sapia:sect3 title="Generating Code with Ant">
         <p>Regis provides an Ant task that may be configured as follows:</p>
         
  <sapia:code><![CDATA[<!-- declaring the taskdef -->
<taskdef classname="org.sapia.regis.ant.CodeGenTask"
    name="codegen">
  <classpath>
    <fileset dir="${project.distributionDir}">
      <include name="sapia_regis.jar"/>
    </fileset>
  </classpath>
</taskdef>
    
<!-- invoking the task -->
<codegen 
  destdir="${basedir}/codegen/src" 
  properties="etc/codegen/bootstrap.properties"
  packagePrefix="org.sapia.regis.sample"
  version="1.0"
  rootClassName="SampleApp" />]]></sapia:code>         
        
        <p>The task takes the following attributes:
	        <ul>
	          <li><b>destdir</b>: indicates the directory where the sources must be generated</li>
	          <li><b>properties</b>:</li> indicates the Regis boostrap file to use for loading (or connecting to) the Registry instance
	          whose contents will be used for generating the code. 
	          <li><b>packagePrefix</b>: the package prefix to use, which will be inserted into the generated sources (and used when creating the source files).</li>
	          <li><b>version:</b> an arbitrary version number, also inserted in the generated sources.</li>	          	          	          
	          <li><b>rootClassName:</b> The name (excluding the package) of the class to use when generating the "root" class (the code generator creates such a root class
	          and corresponding factory to serve as a convenient entry point for applications.</li>
	        </ul>
        </p> 
         
         
       </sapia:sect3>
       
       <sapia:sect3 title="Using the Generated Code">
         <p>
         The following illustrates how to use the generated code. Note
         that the code generator creates a root class (and associated 
         interface), that corresponds to the root of the configuration.
         The generator also creates a factory allowing applications to
         create an instance of the root class, as illustrated below:
         </p>
         <sapia:code>import org.sapia.regis.sample.*;
import org.sapia.regis.*;
import java.util.Properties;
 
...
 
Properties props = new Properties();
  
props.setProperty(RegistryContext.BOOTSTRAP, "etc/codegen/bootstrap.properties");
RegistryContext ctx = new RegistryContext(props);
Registry reg = ctx.connect();
RegisSession s = reg.open();
    
SampleApp appConfig = SampleAppFactory.createFor(reg);
for(DatabasesNode node : appConfig.getDatabases().getDatabasesNodes()){
  System.out.println(node.getUsername() + ", " + node.getUrl());
}

s.close();</sapia:code>         
       </sapia:sect3>
       
       <sapia:sect3 title="Behind the Scenes">
         <p>
         The code generator creates a class hierarchy correspdonding to the node
         hierarchy of the Registry instance that is used as a base for code
         generation. The generator creates packages that match the different node paths 
         under the configuration tree.
         </p>
         <p>
         Instances of the generated classes encapsulate their corresponding node at runtime. Therefore,
         the configuration is not hardwired into the source; the generated classes serve as proxies - sort of a
         strongly-typed abstraction layer.
         </p>         
       </sapia:sect3>
    
    </sapia:sect2>
    
    <sapia:sect2 title="Conclusion">
      <p>Regis can be used to implement a robust, performant, persistent and
      distributed configuration infrastructure.</p>
    </sapia:sect2>
  </sapia:sect1>
</sapia:page>
