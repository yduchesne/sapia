package org.sapia.soto.aop;

import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * @author Yanick Duchesne
 *         <dl>
 *         <dt><b>Copyright: </b>
 *         <dd>Copyright &#169; 2002-2003 <a
 *         href="http://www.sapia-oss.org">Sapia Open Source Software </a>. All
 *         Rights Reserved.</dd>
 *         </dt>
 *         <dt><b>License: </b>
 *         <dd>Read the license.txt file of the jar or visit the <a
 *         href="http://www.sapia-oss.org/license.html">license page </a> at the
 *         Sapia OSS web site</dd>
 *         </dt>
 *         </dl>
 */
public class Invocation {
  private boolean     _invokeNext;
  private Method      _method;
  private MethodProxy _proxy;
  private Object      _instance;
  private Object      _returnVal;
  private Object[]    _args;
  boolean             _invoked;

  /**
   * Constructor for Invocation.
   */
  Invocation(Object instance, Method meth, MethodProxy proxy, Object[] args) {
    _instance = instance;
    _method = meth;
    _proxy = proxy;
    _args = args;
  }

  /**
   * Allows to abort the method invocation that is eventually executed by this
   * instance. The caller must in turn pass a return value that will eventually
   * be returned to the client.
   * <p>
   * This functionality has been implemented in order to bypass a method's
   * invocation, if required. It should be used with care.
   * <p>
   * This method must be called within <code>BeforeAdvice</code> instances
   * only - otherwise does not make sense.
   * 
   * @param returnVal
   *          the "fake" return value that is eventually returned to client
   *          code.
   *  
   */
  public void abortInvoke(Object returnVal) {
    _invoked = true;
    _returnVal = returnVal;
  }

  //  /**
  //   * Signals that the invocation should be stopped.
  //   *
  //   * @see #enable()
  //   * @see #hasNext()
  //   */
  //  public void disable(){
  //    _invokeNext = false;
  //  }
  //  
  //  /**
  //   * Returns true if the next advices in the chain should be invoked.
  //   *
  //   * @see #disable()
  //   * @see #enable()
  //   */
  //  public boolean hasNext(){
  //    return _invokeNext;
  //  }
  //  
  //  /**
  //   * Enables the invocation of the "next" advices in the chain.
  //   *
  //   * @see #disable()
  //   * @see #hasNext()
  //   */
  //  public void enable(){
  //    _invokeNext = true;
  //  }

  /**
   * Returns the name of the method to which this instance corresponds.
   * 
   * @return a method name.
   */
  public String getMethodName() {
    return _method.getName();
  }

  /**
   * Returns the types of the parameters that this method takes.
   * 
   * @return a <code>Class</code> array representing this instance's method
   *         parameter types.
   */
  public Class[] getParameterTypes() {
    return _method.getParameterTypes();
  }

  /**
   * Return the return type of the method to which this instance corresponds.
   * 
   * @return a <code>Class</code> object corresponding to this instance's
   *         method return type.
   */
  public Class getReturnType() {
    return _method.getReturnType();
  }

  /**
   * Returns the value that was returned by the invocation of the method to
   * which this instance corresponds.
   * 
   * @return an <code>Object</code>
   * @throws IllegalStateException
   *           if the method has not yet been invoked.
   */
  public Object getReturnValue() throws IllegalStateException {
    if(!_invoked) {
      throw new IllegalStateException("Method " + _method + " not yet invoked");
    }

    return _returnVal;
  }

  /**
   * Invokes the method to which this instance corresponds.
   * 
   * @throws a
   *           <code>Throwable<code> generated by the underlying method if a
   * problem occurs.
   */
  public Object invoke() throws Throwable {
    if(_invoked) {
      throw new IllegalStateException("Method " + _method
          + "was already invoked");
    }

    _invoked = true;

    return _returnVal = _proxy.invokeSuper(_instance, _args);
  }

  /**
   * Returns <code>true</code> if the method to which this instance
   * corresponds has been invoked.
   * 
   * @return <code>true</code> if the method to which this instance
   *         corresponds has been invoked.
   */
  public boolean wasInvoked() {
    return _invoked;
  }

  /**
   * Returns the instance on which this invocation is to be performed.
   * 
   * @return an <code>Object</code>.
   */
  public Object getTarget() {
    return _instance;
  }

  /**
   * Returns the arguments to be passed to the method that this instance
   * corresponds to.
   * 
   * @return an array of <code>Object</code>.
   */
  public Object[] getArgs() {
    return _args;
  }

  /**
   * Returns the method object that this invocation corresponds to.
   * 
   * @return a <code>Method</code>
   */
  Method getMethod() {
    return _method;
  }

  void setReturnValue(Object val) {
    if(!_invoked) {
      throw new IllegalStateException("Method " + _method + " not yet invoked");
    }
  }
}
