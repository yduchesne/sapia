<sapia:page title="ActiveMQ" xmlns:sapia="http://www.sapia-oss.org/2003/XSL/Transform">
  <sapia:vmenu>
    <sapia:vsection name="Project Home" href="index.html"/>
    <sapia:vsection name="Javadoc" href="maven/api/index.html"/>
    <sapia:vsection name="Maven" href="maven/index.html"/>
  </sapia:vmenu>

  <sapia:sect1 title="ActiveMQ">
    <sapia:section>
      <sapia:path name="home" href="http://www.sapia-oss.org/home.html" />
      <sapia:path name="projects" />
      <sapia:path name="soto" href="../../home.html" />
      <sapia:path name="services" />
      <sapia:path name="activemq" />      
    </sapia:section>
    <toc/>
    
    <sapia:sect2 title="Namespace">
      <ul>
        <li><b>URI</b>: <sapia:command>soto:activemq</sapia:command></li>
        <li><b>Prefix</b>: <sapia:command>mq</sapia:command></li>
      </ul>
    </sapia:sect2>    
    
    <sapia:sect2 title="Overview">
    
      <p>The <a href="http://www.activemq.org" target="mq_site">ActiveMQ</a> JMS server provides an embeddable JMS implementation that
      fits very well with Soto's dependency injection mechanism. The following explains how to configure ActiveMQ in Soto. In fact, explanations
      need not be very exhaustive, since ActiveMQ has been designed with dependency injection in mind, and already provides documentation on how
      to configure the classes in its API (for example, see the following <a href="http://www.activemq.org/site/xml-configuration.html" target="mqdoco">page</a>
      of the ActiveMQ web site).</p>

    </sapia:sect2>

    <sapia:sect2 title="Learning by Example">

      <p>This section introduces usage of the different ActiveMQ configuration elements in Soto, through
      sample configurations forming a hub-and-spoke topology - i.e.: edges (a sender and a receiver) and a central JMS broker.</p>

      <sapia:sect3 title="Receiver">
      <p>The following illustrates how to configure the receiving end, using a JMS queue:</p>

<sapia:code>
<![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq"
          xmlns:ex="soto:example">
          
  <soto:namespace prefix="ex">
    <def class="org.sapia.soto.activemq.example.QueueReceiver"
         name="receiver" />
  </soto:namespace>          
          
  <soto:service id="factory">
    <mq:factory>
      <brokerURL>tcp://localhost:61616</brokerURL>
    </mq:factory> 
  </soto:service>         
  
  <soto:service id="receiver">
    <ex:receiver>
      <queue><mq:queue name="msgQueue" /></queue>    
      <queueConnectionFactory>
          <soto:serviceRef id="factory" />
      </queueConnectionFactory>
    </ex:receiver> 
  </soto:service>           
  
</soto:app>]]>
</sapia:code>

      <p>The first ActiveMQ element in the above configuration is the <sapia:command>mq:factory</sapia:command>
      element, which corresponds to the <sapia:class target="mqfactory" link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/ActiveMQConnectionFactory.html">ActiveMQConnectionFactory</sapia:class>
      class. The element takes the following attribute or element:</p>
      <ul>
        <li><b>brokerURL</b>: takes the URL of the JMS broker to connect to (see the available <a href="http://incubator.apache.org/activemq/configuring-transports.html" target="mquris">URIs</a>).</li>
      </ul>
      <p>All other setters of the <sapia:class>ActiveMQConnectionFactory</sapia:class> class can also be configured, of course. Please have a look at ActiveMQ's documentation
      for more information on these other setters.</p>
      
      <p>The second ActiveMQ element in the configuration is the <sapia:command>mq:queue</sapia:command>
      element, which yields an instance of the <sapia:class target="mqqeue" link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/command/ActiveMQQueue.html">ActiveMQQueue</sapia:class>
      class at initialization time. The element takes the following attributes or elements:</p>
      <ul>
        <li><b>name</b>: the logical name of the queue.</li>
        <li><b>physicalName</b>: the physical name of the queue.</li>        
      </ul>
      
      <p>Soto also has a <sapia:command>mq:topic</sapia:command> element, which yields an instance of the 
      <sapia:class target="mqtopic" link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/command/ActiveMQTopic.html">ActiveMQTopic</sapia:class>
      class at initialization time. The element takes the following attributes or elements:</p>
      <ul>
        <li><b>name</b>: the logical name of the topic.</li>
        <li><b>physicalName</b>: the physical name of the queue.</li>        
      </ul>
      
      <p>For the sake of completeness, here is the code corresponding to the above configuration 
      (see the doc of the <sapia:class target="sotoqreceiver" link="maven/api/org/sapia/soto/activemq/example/QueueReceiver.html">QueueReceiver</sapia:class>
      class for more information):</p>

<sapia:code><![CDATA[package org.sapia.soto.activemq.example;

import java.io.File;
import java.net.URL;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

import org.apache.log4j.xml.DOMConfigurator;
import org.sapia.soto.SotoContainer;
import org.sapia.soto.activemq.MessageListenerFactory;
import org.sapia.soto.activemq.util.QueueMessageProcessor;

public class QueueReceiver extends QueueMessageProcessor 
  implements MessageListener, MessageListenerFactory{
  
  public void onMessage(Message msg) {
    TextMessage txtMsg = (TextMessage)msg;
    try{
      System.out.println(
          "Received message: " + txtMsg.getText());
    }catch(JMSException e){
      e.printStackTrace();
    }
  }
  
  public MessageListener createMessageListener() {
    return this;
  }
  
  public void init() throws Exception {
    super.setMessageListenerFactory(this);
    super.init();
  }
  
  public static void main(String[] args) {
    SotoContainer soto = new SotoContainer();    
    try {
      DOMConfigurator.configure(
          new URL("file:etc/activemq/log.xml"));
      
      soto.load(
          new File("etc/activemq/queueReceiver.xml"));
      soto.start();
      System.out.println("Container started...");
      while(true){
        Thread.sleep(10000000);
      }
    } catch (Exception e) {
      soto.dispose();
      e.printStackTrace();
    }
  }    

}]]>
</sapia:code>      
      
      </sapia:sect3>
      
      <sapia:sect3 title="Sender">
      <p>The following configures the sender part:</p>

<sapia:code>
<![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq"
          xmlns:ex="soto:example">
          
  <soto:namespace prefix="ex">
    <def class="org.sapia.soto.activemq.example.QueueSender"
         name="sender" />
  </soto:namespace>          
          
  <soto:service id="factory">
    <mq:factory>
      <brokerURL>tcp://localhost:61616</brokerURL>
    </mq:factory> 
  </soto:service>         
  
  <soto:service id="sender">
    <ex:sender>
      <queue><mq:queue name="msgQueue" /></queue>    
      <queueConnectionFactory>
          <soto:serviceRef id="factory" />
      </queueConnectionFactory>
    </ex:sender> 
  </soto:service>           
  
</soto:app>]]>
</sapia:code>
    <p>The above does not introduce any new configuration element. The corresponding code
    goes as follows (see the doc of the <sapia:class target="sotoqreceiver" link="maven/api/org/sapia/soto/activemq/example/QueueSender.html">QueueSender</sapia:class>
      class for more information):</p>

<sapia:code>package org.sapia.soto.activemq.example;

import java.io.File;
import java.net.URL;

import org.apache.log4j.xml.DOMConfigurator;
import org.sapia.soto.Service;
import org.sapia.soto.SotoContainer;
import org.sapia.soto.activemq.util.QueueSenderPool;

public class QueueSender extends QueueSenderPool implements Service{
  
  public void sendMessage(String msg) throws Exception{
    System.out.println("Sending message: " + msg);
    super.sendTextMessage(msg);
  }
  
  public static void main(String[] args) {
    try {
      DOMConfigurator.configure(
          new URL("file:etc/activemq/log.xml"));
      SotoContainer soto = new SotoContainer();
      soto.load(new File("etc/activemq/queueSender.xml"));
      soto.start();
      System.out.println("Container started...");
      QueueSender sender = (QueueSender)soto.lookup("sender");
      sender.sendMessage("Hello World!!!");
      soto.dispose();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }  

}</sapia:code>
    </sapia:sect3> 
    <sapia:sect3 title="Broker">
      <p>Now, the most complex part: the broker. Soto provides the <sapia:command>mq:broker</sapia:command> element, which
      corresponds to the <sapia:class target="mqbroker" link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/broker/BrokerService.html">BrokerService</sapia:class>
      class. The ActiveMQ web site has exhaustive <a href="http://www.activemq.org/site/how-do-i-embed-a-broker-inside-a-connection.html" target="mqbrokerdoc">documentation</a> about broker configuration (persistency, topologies, etc.), and for a complete
      reference, you should have a look at it.
      </p>
      <p>In any case, here's the configuration for our broker:</p>
      
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq">
          
  <soto:service>
    <mq:broker persistent="false" brokerName="server" useJmx="false">
      <!--persistenceFactory>
        <mq:journaledJDBC useJournal="true" 
          journalLogFiles="5" 
          dataDirectory="activemq-data" />
        </persistenceFactory-->
      <!--persistenceAdapter>
        <soto:new
        class="org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter">
        <arg><soto:file name="activemq-data" create="true" /></arg>
        <maxDataFileLength>33554432</maxDataFileLength>
        </soto:new>
        </persistenceAdapter-->
      <persistenceAdapter>
        <mq:memoryPersistenceAdapter />
      </persistenceAdapter>
      <connector>
        <mq:transportConnector>
          <uri>
            <!--soto:uri value="tcp://localhost:0" /-->
            <soto:uri value="tcp://localhost:61616" />
          </uri>
          <discoveryUri>
            <soto:uri value="multicast://default" />
          </discoveryUri>
        </mq:transportConnector>
      </connector>
      <networkConnector>
        <soto:uri value="multicast://default" />
      </networkConnector>
    </mq:broker>
  </soto:service>

</soto:app>]]></sapia:code>

    <p>The above configuration shows how to configure a <sapia:class>BrokerService</sapia:class> using
    Soto. As was explained, the <sapia:command>mq:broker</sapia:command> element corresponds to the <sapia:class>BrokerService</sapia:class>
    class itself.</p>
    
    <p>The next element pertains to persistency: the <sapia:command>mq:memoryPersistenceAdapter</sapia:command> element corresponds to the 
    <sapia:class link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/store/memory/MemoryPersistenceAdapter.html"
    target="mqmempersistence">MemoryPersistenceAdapter</sapia:class> class. As the configuration shows, other modes of persistency could have been chosen: the
    <sapia:command>mq:journaledJDBC</sapia:command> corresponds to the <sapia:class link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/store/DefaultPersistenceAdapterFactory.html"
    target="mqdefpersistence">DefaultPersistenceAdapterFactory</sapia:class> class. In addition, the example shows how a
    <sapia:class link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/store/kahadaptor/KahaPersistenceAdapter.html"
    target="mqkahapersistence">KahaPersistenceAdapter</sapia:class> could be configured, through Soto's constructor dependency-injection (the class does not have
    an empty constructor, so no Soto object definition could be created for it).    
    </p>
    
    <p>The next step is to configure the broker's connector. In this case, we are using the <sapia:command>mq:transportConnector</sapia:command> element, which
    corresponds to the <sapia:class link="http://incubator.apache.org/activemq/maven/activemq-core/apidocs/org/apache/activemq/broker/TransportConnector.html"
    target="mqtransconnector">TransportConnector</sapia:class> class. In our case, we are binding the broker to the network using the TCP transport, on port 0 (this
    would allow us to start multiple brokers on the same host, using anonymous ports). We are also configuring the connector to listen for the presence of other brokers 
    on the network using multicast.</p>
    
    <p>Lastly, in order for the broker to broadcast its presence to other brokers, we add a <sapia:command>networkConnector</sapia:command> element - we have thus 
    implemented a network of brokers, as explained in ActiveMQ's 
    <a href="http://www.activemq.org/site/networks-of-brokers.html" target="mqnetofbrokers">documentation</a>.</p>
    </sapia:sect3>
     
    </sapia:sect2>
    
    
    
    <sapia:sect2 title="Advanced Configuration">
    <p>This section describes the advanced possibilities when a system needs to support a high volume a messages. Instead of creating a single producer
    or consumer on a given queue or topic, it is preferred to use a pool approach where many producers or many consumers can share the load. The following
    describes the support available in Soto to create and use pools with Active MQ.</p>
    
    <sapia:sect3 title="Queue Sender Pool">
    <p>The <sapia:class target="queuesenderpool" link="maven/api/org/sapia/soto/activemq/util/QueueSenderPool.html">QueueSenderPool</sapia:class>
    creates a pool of senders over a given queue. The objects in the pool are created from a single
    <sapia:class target="queueconnection" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/QueueConnection.html">QueueConnection</sapia:class> 
    and each sender is created in a separate
    <sapia:class target="queuesession" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/QueueSession.html">QueueSession</sapia:class> 
    as suggested by the JMS best practices.</p>
    
    <p>The following gives an example of how to create a queue sender pool:</p>
      
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq">
          
  <soto:service id="connectionFactory">
      <mq:factory>
          <brokerURL>tcp://localhost:61616</brokerURL>
      </mq:factory> 
  </soto:service>         
  
  <soto:service id="senderPool">
      <mq:queueSenderPool maxActive="3" maxIdle="3">
          <queue><mq:queue name="sapia.test.inbox" /></queue>    
          <queueConnectionFactory>
              <soto:serviceRef id="connectionFactory" />
          </queueConnectionFactory>
      </mq:queueSenderPool>
  </soto:service>
  
</soto:app>]]></sapia:code>
    
    <p>As seen in the previous examples, the first thing to do is create the connection factory to the broker using the
     <sapia:command>mq:factory</sapia:command> element. The second service of the example is the pool of queue sender that
     is created using the element <sapia:command>mq:queueSenderPool</sapia:command>. The possible parameters of a 
     <sapia:class target="queuesenderpool" link="maven/api/org/sapia/soto/activemq/util/QueueSenderPool.html">QueueSenderPool</sapia:class> are:</p>
    <ul>
      <li><b>maxActive</b>: The maximum number of active queue senders in the pool.</li>
      <li><b>maxIdle</b>: The maximum number of idle queue senders in the pool.</li>
      <li><b>transacted</b>: Defines the transactionnal behavior of the sender - "true" to use JMS transaction or "false" (default value).</li>
      <li><b>queue</b>: The destination JMS queue to which the senders will send the messages.</li>
      <li><b>queueConnectionFactory</b>: The queue connection factory to use for the pool.</li>
    </ul>
     
    <p>When the queue sender pool is created, the pool is empty: the senders are created as the demand goes. The pool will create objects of
    type <sapia:class target="queuesenderpool" link="maven/api/org/sapia/soto/activemq/util/QueueSenderRef.html">QueueSenderRef</sapia:class>
    that contains the two attributes: queue sender and queue session. When using the pool, it is very important to follow the simple procedure:</p>
    <ol>
      <li>acquire a queue sender reference from the pool.</li>
      <li>create a message using the session of the queue sender reference.</li>
      <li>send the message using the sender of the queue sender reference.</li>
      <li>put back the queue sender reference into the pool.</li>
    </ol>
    
    <p>Here a code example of how to use the queue sender pool:</p>

<sapia:code>
  ...  
  public void sendText(String text) throws Exception {
    QueueSenderRef ref = null;
    try {
      ref = (QueueSenderRef) _queueSenderPool.borrowObject();
      TextMessage textMessage = ref.getSession().createTextMessage(msg);
      ref.getSender().send(textMessage);
    } finally {
      if (ref != null) {
        _queueSenderPool.returnObject(ref);
      }
    }
  }
  ...
</sapia:code>
    </sapia:sect3>
    
    
    <sapia:sect3 title="Queue Receiver Pool">
    <p>The <sapia:class target="queuereceiverpool" link="maven/api/org/sapia/soto/activemq/util/QueueReceiverPool.html">QueueReceiverPool</sapia:class>
    creates a pool of consumers over a given queue. The objects in the pool are created from a single
    <sapia:class target="queueconnection" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/QueueConnection.html">QueueConnection</sapia:class> 
    and each sender is created in a separate
    <sapia:class target="queuesession" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/QueueSession.html">QueueSession</sapia:class> 
    as suggested by the JMS best practices. The important thing to remember is that JMS sessions are not thread safe. Therefore if 
    you want to use multiple threads to scale your system you will need many sessions.</p>
    
    <p>The following gives an example of how to create a queue receiver pool:</p>
      
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq">
          
  <soto:service id="connectionFactory">
      <mq:factory>
          <brokerURL>tcp://localhost:61616</brokerURL>
      </mq:factory> 
  </soto:service>         
  
  <soto:service id="receiverPool">
      <mq:queueReceiverPool selectorString="" poolSize="5">
          <queue><mq:queue name="sapia.test.inbox" /></queue>    
          <queueConnectionFactory>
              <soto:serviceRef id="connectionFactory" />
          </queueConnectionFactory>
      </mq:queueReceiverPool>
  </soto:service>           
  
</soto:app>]]></sapia:code>
    
    <p>As seen in the previous examples, the first thing to do is create the connection factory to the broker using the
     <sapia:command>mq:factory</sapia:command> element. The second service of the example is the pool of queue receivers that
     is created using the element <sapia:command>mq:queueReceiverPool</sapia:command>. The possible parameters on a
     <sapia:class target="queuereceiverpool" link="maven/api/org/sapia/soto/activemq/util/QueueReceiverPool.html">QueueReceiverPool</sapia:class>
     are:</p>
    <ul>
      <li><b>poolSize</b>: The number of queue receivers in the pool.</li>
      <li><b>selectorString</b>: The JMS selector string to filter incoming messages on the queue.</li>
      <li><b>transacted</b>: Defines the transactionnal behavior of the receiver - "true" to use JMS transaction or "false" (default value).</li>
      <li><b>queue</b>: The destination JMS queue to which the senders will listen for messages.</li>
      <li><b>queueConnectionFactory</b>: The queue connection factory to use for the pool.</li>
    </ul>
   
    <p>Upon creation of the queue receiver pool, a queue connection is establish and a queue session is created for each queue receiver
    (as specified by the poolSize attribute). The next logical step is to register a JMS
    <sapia:class target="messagelistener" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/MessageListener.html">MessageListener</sapia:class> 
    of the receiver pool: that action will register the listener with each receiver of the pool. Form that moment your listener will start
    receiving incoming messages from the various sessions. Note, your message listener implementation must be thread safe as it will be
    called by thread of the various queue sessions of the pool.</p>
        
    <p>Here a code example of how to use the queue receiver pool:</p>

<sapia:code>
public class QueueReceiverPoolExample implements MessageListener {
  private QueueReceiverPool _pool;
  ...
  public void setPool(QueueReceiverPool aPool) {
    _pool = aPool;
    _pool.setMessageListener(this);
  }
  ...
  public void dispose() {
    _pool.setMessageListener(null);
  }
  ...
  public void onMessage(Message aMessage) {
    System.out.println(
        "Received a message from a queue receiver: " + aMessage);
  }
  ...
</sapia:code>
    </sapia:sect3>

    
    <sapia:sect3 title="Topic Publisher Pool">
    <p>The <sapia:class target="topicpublisherpool" link="maven/api/org/sapia/soto/activemq/util/TopicPublisherPool.html">TopicPublisherPool</sapia:class>
    creates a pool of publishers over a given topic. The objects in the pool are created from a single
    <sapia:class target="topicconnection" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/TopicConnection.html">TopicConnection</sapia:class> 
    and each publisher is created in a separate
    <sapia:class target="topicsession" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/TopicSession.html">TopicSession</sapia:class>
    as suggested by the JMS best practices.</p>
    
    <p>The following gives an example of how to create a topic publisher pool:</p>
      
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq">
          
  <soto:service id="connectionFactory">
      <mq:factory>
          <brokerURL>tcp://localhost:61616</brokerURL>
      </mq:factory> 
  </soto:service>         
  
  <soto:service id="publisherPool">
      <mq:topicPublisherPool maxActive="3" maxIdle="3">
          <topic><mq:topic name="sapia.test.inbox" /></topic>
          <topicConnectionFactory>
              <soto:serviceRef id="connectionFactory" />
          </topicConnectionFactory>
      </mq:topicPublisherPool>
  </soto:service>
  
</soto:app>]]></sapia:code>
    
    <p>As seen in the previous examples, the first thing to do is create the connection factory to the broker using the
     <sapia:command>mq:factory</sapia:command> element. The second service of the example is the pool of topic publishers that
     is created using the element <sapia:command>mq:topicPublisherPool</sapia:command>. The possible parameters of a 
     <sapia:class target="topicpublisherpool" link="maven/api/org/sapia/soto/activemq/util/TopicPublisherPool.html">TopicPublisherPool</sapia:class> are:</p>
    <ul>
      <li><b>maxActive</b>: The maximum number of active topic publishers in the pool.</li>
      <li><b>maxIdle</b>: The maximum number of idle topic publishers in the pool.</li>
      <li><b>transacted</b>: Defines the transactionnal behavior of the publisher - "true" to use JMS transaction or "false" (default value).</li>
      <li><b>topic</b>: The destination JMS topic to which the publishers will send the messages.</li>
      <li><b>topicConnectionFactory</b>: The topic connection factory to use for the pool.</li>
    </ul>
     
    <p>When the topic publisher pool is created, the pool is empty: the publishers are created as the demand goes. The pool will create objects of
    type <sapia:class target="topicpublisherpool" link="maven/api/org/sapia/soto/activemq/util/TopicPublisherRef.html">TopicPublisherRef</sapia:class>
    that contains the two attributes: topic subscriber and topic session. When using the pool, it is very important to follow the simple procedure:</p>
    <ol>
      <li>acquire a topic subscriber reference from the pool.</li>
      <li>create a message using the session of the topic subscriber reference.</li>
      <li>send the message using the publisher of the topic subscriber reference.</li>
      <li>put back the topic subscriber reference into the pool.</li>
    </ol>
    
    <p>Here a code example of how to use the topic subscriber pool:</p>

<sapia:code>
  ...  
  public void sendText(String text) throws Exception {
    TopicPublisherRef ref = null;
    try {
      ref = (TopicPublisherRef) _topicSubscriberPool.borrowObject();
      TextMessage textMessage = ref.getSession().createTextMessage(msg);
      ref.getPublisher().send(textMessage);
    } finally {
      if (ref != null) {
        _topicSubscriberPool.returnObject(ref);
      }
    }
  }
  ...
</sapia:code>
    </sapia:sect3>
    
    
    <sapia:sect3 title="Topic Subscriber Pool">
    <p>The <sapia:class target="topicsubscriberpool" link="maven/api/org/sapia/soto/activemq/util/TopicSubscriberPool.html">TopicSubscriberPool</sapia:class>
    creates a pool of subscribers over a given topic. The objects in the pool are created from a single
    <sapia:class target="topicconnection" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/TopicConnection.html">TopicConnection</sapia:class> 
    and each sender is created in a separate
    <sapia:class target="topicsession" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/TopicSession.html">TopicSession</sapia:class> 
    as suggested by the JMS best practices. The important thing to remember is that JMS sessions are not thread safe. Therefore if 
    you want to use multiple threads to scale your system you will need many sessions. However caution must be taken when using multiple
    subscribers on a topic. As the JMS specification defines, each session of a topic connection will receive a copy of the message delivered
    on a topic. Therefore is you create a pool 5 subscribers, be aware that your message listener will receive 5 copies of the same message.</p>
    
    <p>The following gives an example of how to create a topic subscriber pool:</p>
      
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:mq="soto:activemq">
          
  <soto:service id="connectionFactory">
      <mq:factory>
          <brokerURL>tcp://localhost:61616</brokerURL>
      </mq:factory> 
  </soto:service>         
  
  <soto:service id="subscriberPool">
      <mq:topicSubscriberPool selectorString="" poolSize="1">
          <topic><mq:topic name="sapia.test.inbox" /></topic>
          <topicConnectionFactory>
              <soto:serviceRef id="connectionFactory" />
          </topicConnectionFactory>
      </mq:topicSubscriberPool>
  </soto:service>           
  
  
</soto:app>]]></sapia:code>
    
    <p>As seen in the previous examples, the first thing to do is create the connection factory to the broker using the
     <sapia:command>mq:factory</sapia:command> element. The second service of the example is the pool of topic subscribers that
     is created using the element <sapia:command>mq:topicSubscriberPool</sapia:command>. The possible parameters on a
     <sapia:class target="topicsubscriberpool" link="maven/api/org/sapia/soto/activemq/util/TopicSubscriberPool.html">TopicSubscriberPool</sapia:class>
     are:</p>
    <ul>
      <li><b>poolSize</b>: The number of topic subscriber in the pool.</li>
      <li><b>selectorString</b>: The JMS selector string to filter incoming messages on the topic.</li>
      <li><b>transacted</b>: Defines the transactionnal behavior of the subscriber - "true" to use JMS transaction or "false" (default value).</li>
      <li><b>topic</b>: The destination JMS topic to which the subscriber will listen for messages.</li>
      <li><b>topicConnectionFactory</b>: The topic connection factory to use for the pool.</li>
    </ul>
   
    <p>Upon creation of the topic subscriber pool, a topic connection is establish and a topic session is created for each topic publisher
    (as specified by the poolSize attribute). The next logical step is to register a JMS
    <sapia:class target="messagelistener" link="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/jms/MessageListener.html">MessageListener</sapia:class> 
    of the subscriber pool: that action will register the listener with each subscriber of the pool. Form that moment your listener will start
    receiving incoming messages from the various sessions. Note, your message listener implementation must be thread safe as it will be
    called by thread of the various queue sessions of the pool. And as mentioned above, you will get as much copy of the same message as you
    have sessions in your pool.</p>
        
    <p>Here a code example of how to use the topic subscriber pool:</p>

<sapia:code>
public class TopicSubscriberPoolExample implements MessageListener {
  private TopicSubscriberPool _pool;
  ...
  public void setPool(TopicSubscriberPool aPool) {
    _pool = aPool;
    _pool.setMessageListener(this);
  }
  ...
  public void dispose() {
    _pool.setMessageListener(null);
  }
  ...
  public void onMessage(Message aMessage) {
    System.out.println(
        "Received a message from a topic publisher: " + aMessage);
  }
  ...
</sapia:code>
    </sapia:sect3>
    
    </sapia:sect2>    
    
    
    <sapia:sect2 title="ActiveSpace">
      <sapia:sect3 title="Basics">
      <p>The <a href="http://activespace.codehaus.org" target="activespace">ActiveSpace</a> project (which implements a JavaSpace-like facade over JMS) 
      can be used in conjunction with ActiveMQ. Soto provides an extended interface of ActiveSpace's <sapia:class>SpaceFactory</sapia:class> interface,
      used to create <sapia:class>Space</sapia:class> instances over JMS. Soto's 
      <sapia:class target="sotoactivespacefactory" link="maven/api/org/sapia/soto/activemq/space/ActiveSpaceFactory.html">ActiveSpaceFactory</sapia:class>
      offers an additional <sapia:command>createSpace()</sapia:command> method, which differs from the parent interface's by the fact that it takes a 
      "template" object instead of a SQL92 selector string. The interface 
      <sapia:class target="sotoactivespace" link="maven/api/org/sapia/soto/activemq/space/ActiveSpaceService.html">implementation</sapia:class>
      internally converts the template object to a SQL92 selector string, using the public, not null, primitive fields of the object 
      (including fields of type <sapia:class>java.lang.String</sapia:class>).
      </p>
      <p>To use the <sapia:class>ActiveSpaceService</sapia:class>, first implement the classes whose objects will be exchanged through the space
      (these objects are named "entries" in JavaSpace terminology). For example, here is a sample "entry":</p>
      
<sapia:code>public void RequestEntry implements java.io.Serializable{

  public String requestId, version;
  
  private Object data;
  
  public RequestEntry(Object data){
   this.data = data;
  }
  
  public Object getData(){
    return data;
  }
}</sapia:code>

      <p>Then, you can configure an <sapia:class>ActiveSpaceService</sapia:class> as part of the nodes
      that send/receive these entries:</p>

<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto" 
  xmlns:mq="soto:activemq">
  ...
  <soto:service id="spaceFactory">
    <mq:spaceFactory>
      <connectionFactory>
        <mq:factory>
          <brokerURL>vm://localhost</brokerURL>
        </mq:factory>
      </connectionFactory>
    </mq:spaceFactory>
  </soto:service>
  ...
</soto:app>]]></sapia:code>

      <p>The <sapia:command>mq:spaceFactory</sapia:command> element corresponds to the <sapia:class>ActiveSpaceService</sapia:class>
      class. It takes a single <sapia:command>connectionFactory</sapia:command> element, which allows passing the JMS 
      <sapia:class>ConnectionFactory</sapia:class> over which <sapia:class>Space</sapia:class> instances will be created.</p>
      
      <p>Now suppose you would want to inject a <sapia:class>Space</sapia:class> instance to a bean/service of yours; you could use
      the <sapia:command>mq:space</sapia:command> element for this:</p>
      
<sapia:code><![CDATA[...
  <soto:service>
    <acme:myService>
      <space>
        <mq:space factory="spaceFactory" destination="test"
          deliveryMode="DISPATCH_ONE_CONSUMER">
          <template>
            <soto:new
              class="org.acmespace.RequestEntry">
              <version>1.0</version>
            </soto:new>
          </template>
        </mq:space>
      </space>
    </acme:myService>
  </soto:service>]]></sapia:code>      

      <p>The <sapia:command>mq:space</sapia:command> element takes the following attributes/elements:</p>
      
      <ul>
        <li><b>factory</b>: the identifier of the <sapia:class>ActiveSpaceFactory</sapia:class> to use in order to create the desired <sapia:class>Space</sapia:class>.</li>
        <li><b>destination</b>: the name of the JMS destination through which entries are sent/received.</li>
        <li><b>deliveryMode</b>: the delivery mode, as specified in the <sapia:class>SpaceFactory</sapia:class> javadoc.</li>
        <li><b>template</b>: the template object to use to create the space.</li>        
      </ul>
      
      <p>Now, once a space has been created, it is only a matter of using the put/take methods of the space to exchange entries. Take operations will
      only yield those objects that match the originally defined template.
      </p>
      </sapia:sect3>
      <sapia:sect3 title="Request-Reply">
      <p>The <sapia:class>ActiveSpaceFactory</sapia:class>
      in fact creates instances of the <sapia:class target="sotoactivespace" link="maven/api/org/sapia/soto/activemq/space/ActiveSpace.html">ActiveSpace</sapia:class>
      interface. That interface adds additional methods that support pseudo-polymorphic behavior (see the interface's javadoc), as well as the 
      <a target="requestReply" href="http://www.enterpriseintegrationpatterns.com/RequestReplyJmsExample.html">request-reply</a> pattern. The pattern's implementation here relies on 
      three classes/interfaces:
      <ul>
        <li>The <sapia:class>ActiveSpace</sapia:class> interface (in fact, the <sapia:command>request()</sapia:command> and <sapia:command>reply()</sapia:command>
        methods of that interface).</li>
        <li>The <sapia:class target="request" link="maven/api/org/sapia/soto/activemq/space/Request.html">Request</sapia:class> class.</li>
        <li>The <sapia:class target="request" link="maven/api/org/sapia/soto/activemq/space/Reply.html">Reply</sapia:class> class.</li>        
      </ul>
      Now, given these elements, we will demonstrate usage of the request-reply pattern. First, let's design the request/reply data classes that will
      be used:
      </p>
<sapia:code>public class RequestData implements Serializable{

  private String data;

  public void setData(String data){
    this.data = data;
  }
}

public class ReplyData implements Serializable{

  private String data;

  public void setData(String data){
    this.data = data;
  }
}</sapia:code>
      <p>Of course in real life the request and response data classes would most probably look a lot different... And now, here is the code corresponding
      the requestor's side:</p>
      
<sapia:code>RequestData reqData = new RequestData();
reqData.setData("Hello world");
Request req = Request.create(reqData);

// assuming that space is a Space instance
Space replySpace = ((ActiveSpace)space).request(req, 10000, null);

Reply reply = replySpace.take(10000);

if(reply == null){
  System.out.println("No reply within delay");
  replySpace.close(); // do not forget
}
else{
  System.out.println(reply.getData());
  replySpace.close();
}</sapia:code>

      <p>... And now the replier's side:</p>

<sapia:code>Request req = (Request)space.take();
RequestData reqData = (RequestData)req.getData();
ResponseData resData = new ResponseData();
resData.setData("ECHO: " + reqData.getData());
Response res = Response.create(resData, 10000);

// assuming that space is a Space instance
((ActiveSpace)space).reply(res, 10000);</sapia:code>

      <p>
      One interesting point is that the <sapia:command>request()</sapia:command> method returns a <sapia:class>Space</sapia:class>
      instance. That instance can be used to receive one to potentially many replies. This can be handy in scenarios where multiple
      repliers can potentially return data back to the requestor. Such scenarios are frequent in grid-like architectures.
      </p>
      <p>
      Another element worth of mention is that "pseudo-polymorphism" can be used both on the requestor and replier sides:
      </p>
<sapia:code>// on the requestor's side we have:
Dog d = new Dog();
d.setName("Rex");
Request req = Request.create(d);
Space replySpace = ((ActiveSpace)space).request(req, 10000, Animal.class);
...

// and on the replier's side: 
ActiveSpace space = (ActiveSpace)factory.createSpace("animals", 
   SpaceFactory.DISPATCH_ONE_CONSUMER, new Animal());
Request req = (Request)space.take(); 
...</sapia:code>
      <p>Note that entry matching is done based on the request's data, not on the <sapia:class>Request</sapia:class>
      instance itself.</p>
      </sapia:sect3>      
    </sapia:sect2>

    
    <sapia:sect2 title="ActiveCluster">
      <sapia:sect3 title="Basics">
      <p>The <a href="http://activecluster.codehaus.org" target="activecluster">ActiveCluster</a> project (which implements
      a cluster group communication channel over JMS) can be used in conjunction with ActiveMQ. Soto provides some simple XML
      tags to facilitate the creation of a
      <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/ClusterFactory.html">ClusterFactory</sapia:class>
      service and the creation and injection of a new
      <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/Cluster.html">Cluster</sapia:class>
      in your class.</p>
      </sapia:sect3>
      
      <sapia:sect3 title="ClusterFactory">
      <p>The <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/ClusterFactory.html">ClusterFactory</sapia:class>
      is required in order to create a new cluster instance. Here's an example of how to create a cluster factory service:</p>

<sapia:code><![CDATA[
  <soto:service>
  <!-- First create the JMS connection factory service -->
  <soto:service id="connectionFactory">
      <mq:factory>
          <brokerURL>vm://localhost?broker.persistent=false</brokerURL>
      </mq:factory> 
  </soto:service>         
  
  <!-- Then create the cluster factory service -->
  <soto:service id="clusterFactory">
      <mq:clusterFactory inactiveTime="60000">
          <connectionFactory>
              <soto:serviceRef id="connectionFactory" />
          </connectionFactory>
      </mq:clusterFactory>
  </soto:service>
  ...
  </soto:service>]]></sapia:code>      
      
      <p>The cluster factory is created with the element <sapia:command>mq:clusterFactory</sapia:command>. The only required
      argument needed for a new cluster factory is a JMS connection factory. In the previous example, the creation of the
      JMS connection factory comes first (using the element <sapia:command>mq:factory</sapia:command>) and then it is added
      to the cluster factory service.
      </p>
      
      <p>The other available parameters of the cluster factory service are:
      <ul>
        <li><b><sapia:command>acknowledgeMode</sapia:command>:</b> Defines the JMS acknowledge mode of the created clusters. Possible values are:
        <ul>
          <li> '1' for auto acknowledge mode (default value)</li>
          <li> '2' for client acknowledge mode</li>
          <li> '3' for dups ok acknowledge mode</li>
        </ul>
        <br/></li>
        <li><b><sapia:command>dataTopicPrefix</sapia:command>:</b> The prefix name of the JMS destination created by the cluster.
        <ul>
        </ul>
        <br/></li>
        <li><b><sapia:command>deliveryMode</sapia:command>:</b> Defines the JMS delivery mode of the created clusters. Possible values are:
        <ul>
          <li> '1' for non-persistent delivery mode (default value)</li>
          <li> '2' for persistent delivery mode</li>
        </ul>
        <br/></li>
        <li><b><sapia:command>inactiveTime</sapia:command>:</b> Defines the inactivity period in millisecond before a cluster times out
        and considered non responsive.
        <ul>
        </ul>
        <br/></li>
        <li><b><sapia:command>transacted</sapia:command>:</b> Defines the JMS transaction behavior of the created cluster. Possible values are:
        <ul>
          <li> 'false' for non-transactionnal mode (default value)</li>
          <li> 'true' for transactionnal mode</li>
        </ul>
        <br/></li>
        <li><b><sapia:command>useQueueForInbox</sapia:command>:</b> Defines if the created clusters should use JMS queues instead of topic. Possible values are:
        <ul>
          <li> 'false' to use JMS topic in the cluster (default value)</li>
          <li> 'true' to use JMS queue in the cluster</li>
        </ul>
        <br/></li>
      </ul>
      </p>
      </sapia:sect3>
      
      <sapia:sect3 title="Cluster">
      <p>Once a cluster factory service is created it is possible to create new cluster instances and to inject them into your own services.
      The fist thing is to have a service that would require a
      <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/Cluster.html">Cluster</sapia:class>
      to communicate with other peers. Here a quick example of such a class called <sapia:class>ClusterPeer</sapia:class> :
      </p>

<sapia:code>public class ClusterPeer implements Service, MessageListener {

  private Cluster _cluster;
  private MessageConsumer _consumer;
  
  public void setCluster(Cluster aCluster) {
    _cluster = aCluster;
  }
  
  public void init() throws Exception {
    if (_cluster == null) {
      throw new ConfigurationException("The active cluster is not set");
    }
  }

  public void start() throws Exception {
    // Create a new consumer on the cluster destination
    _consumer = _cluster.createConsumer(_cluster.getDestination());
    _consumer.setMessageListener(this);
    _cluster.start();
  }

  public void dispose() {
    try {
      _consumer.close();
      _cluster.stop();
    } catch (JMSException jmse) {
      jmse.printStackTrace();
    }
  }

  public void sendMessage(String aText) throws JMSException {
    // Send a text message to the cluster
    TextMessage jmsMessage = _cluster.createTextMessage(aText);
    _cluster.send(_cluster.getDestination(), jmsMessage);
  }
  
  public void onMessage(Message aJmsMessage) {
    // Received a text message from the cluster
    if (aJmsMessage instanceof TextMessage) {
      try {
        System.out.println("Received: " +
            ((TextMessage) aJmsMessage).getText());
      } catch (JMSException jmse) {
        jmse.printStackTrace();
      }
    }
  }
}</sapia:code>

      <p>The important things to look for in the previous code example are:
      <ul>
          <li>the <sapia:command>setCluster()</sapia:command> method throught which Soto will inject the create
              <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/Cluster.html">Cluster</sapia:class>
              instance.
          </li>
          <li>the <sapia:command>init()</sapia:command>, <sapia:command>start()</sapia:command> and <sapia:command>stop()</sapia:command> methods
              that are managing the lifecycle of the service. Those methods are called by the Soto container.
          </li>
          <li>the <sapia:command>sendMessage()</sapia:command> method that allow to send a simple text message to the cluster.
          </li>
          <li>the <sapia:command>onMessage()</sapia:command> method through which it receives all the messages from the cluster.
          </li>
      </ul>
      </p>
      
      <p>Now here is the necessary XML configuration to create a new <sapia:class>ClusterPeer</sapia:class> instance and to inject a
      <sapia:class taget="activecluster" link="http://activecluster.codehaus.org/maven/apidocs/org/activecluster/Cluster.html">Cluster</sapia:class>
      instance. The following example assumes that a cluster factory service is created as described in the cluster factory example
      of the previous section.
      </p>

<sapia:code><![CDATA[
<soto:service>
  <soto:namespace prefix="test">
      <def class="org.sapia.soto.activemq.cluster.ClusterPeer"
           name="peer" />
  </soto:namespace>          

  ...

  <soto:service id="peerA">
      <test:peer>
          <cluster>
              <mq:cluster groupName="sapia.soto.test">
                  <clusterFactory>
                      <soto:serviceRef id="clusterFactory" />
                  </clusterFactory>
              </mq:cluster>
          </cluster>
      </test:peer>
  </soto:service>
</soto:service>]]></sapia:code>      

     <p>The cluster instance is created by the element <sapia:command>mq:cluster</sapia:command> which takes two required arguments:
     <ol>
        <li><sapia:class>groupName</sapia:class>: The logical name of the cluster group. Clusters communicate within the same group.
        <br/></li>
        <li><sapia:class>clusterFactory</sapia:class>: Defines the cluster factory to use for the creation of the cluster.
        <br/></li>
     </ol>
     </p>
     
     <p>It is just a question of adding peers as you need in the cluster and you have your own group communication channel
     "ala" <sapia:class target="jgroups" link="http://www.jgroups.org/javagroupsnew/docs/index.html">JGroups</sapia:class>,
     but with a JMS implementation. For more information on how to use a cluster and the possibilities it offers, please
     look at the <a href="http://activecluster.codehaus.org" target="activecluster">ActiveCluster</a> documentation.
     </p>
      </sapia:sect3>
    </sapia:sect2>
    
  </sapia:sect1>
</sapia:page>
