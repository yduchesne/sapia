<sapia:page title="Ubik Cookbook" xmlns:sapia="http://www.sapia-oss.org/2003/XSL/Transform">
  <sapia:vmenu>
    <sapia:vsection name="Project Home" href="home.html"/>
    <sapia:vsection name="Wiki" href="http://code.google.com/p/sapia/wiki/Ubik"/>
    <sapia:vsection name="RMI" href="rmi.html">
      <sapia:vitem name="For Dummies" href="rmi.html#dummies" />
      <sapia:vitem name="Believing" href="rmi.html#believing" />
      <sapia:vitem name="Architecture" href="architecture.html" />
      <sapia:vitem name="Tutorial" href="tutorial.html" />    
    </sapia:vsection>
    
    <sapia:vsection name="Naming" href="naming.html">
      <sapia:vitem name="Robust Naming" href="naming.html#robust" />
      <sapia:vitem name="Usage" href="naming.html#usage" />
      <sapia:vitem name="Advanced" href="naming.html#advanced" />    
    </sapia:vsection>
    
    <sapia:vsection name="Transports">
      <sapia:vitem name="NIO/TCP" href="transport/nio_tcp.html" />
      <sapia:vitem name="HTTP" href="transport/http.html" />
	  <sapia:vitem name="Standard/TCP" href="transport/standard_tcp.html" />
    </sapia:vsection>  
    
    <sapia:vsection name="Group Comm" href="group_communication.html">
      <sapia:vitem name="Event Channel" href="group_communication.html#eventchannel" />
      <sapia:vitem name="Protocol" href="group_communication.html#control_protocol" />    
      <sapia:vitem name="Avis" href="group_communication.html#using_avis" />
      <sapia:vitem name="UDP Unicast" href="group_communication.html#udp_unicast" />
    </sapia:vsection>
          
    <sapia:vsection name="Customization" href="customization.html">
      <sapia:vitem name="Logging" href="customization.html#logging" />    
      <sapia:vitem name="Stats" href="customization.html#stats" />
      <!--sapia:vitem name="JMX" href="customization.html#jmx" /-->
      <sapia:vitem name="Stubs" href="customization.html#stubs" />
      <sapia:vitem name="Callbacks" href="customization.html#callbacks" />    
    </sapia:vsection>                   
    
    <sapia:vsection name="FAQ" href="faq.html">
      <sapia:vitem name="Licensing" href="faq.html#licensing" />    
      <sapia:vitem name="Networking" href="faq.html#networking" />
    </sapia:vsection>
    
    <sapia:vsection name="Javadoc" href="maven/api/index.html"/>
    <sapia:vsection name="Download" href="download.html"/>
    <sapia:vsection name="Mailing List" href="list.html"/>
  </sapia:vmenu>

  <sapia:sect1 title="Cookbook" alias="cookbook">
    <sapia:section>
      <sapia:path name="home" href="../../home.html" />
      <sapia:path name="projects" />
      <sapia:path name="ubik" href="home.html" />
      <sapia:path name="rmi" href="rmi.html" />
      <sapia:path name="tutorial" href="tutorial.html" />      
      <sapia:path name="cookbook" />      
    </sapia:section>  
  
    <toc/>
    <sapia:sect-desc>
    <p>This page provides a few recipes that should help developers get started with Ubik.</p>

    </sapia:sect-desc>
    
    <sapia:sect2 title="A Note on Configuration" alias="config"> 
      <p>
      Ubik is configured with system properties, and allows overriding, for certain components of the system, at the instance level.
      The framework is meant to provide remoting support for a whole JVM, and it therefore made sense to support configuration through system properties.
      </p>   
      <p>
      Most properties are defined as part of the <sapia:classlink>org.sapia.ubik.rmi.Consts</sapia:classlink> 
      interface, except for specific parts of the framework that represent implementation-specific sub-components (in such case, the properties are defined 
      in interfaces for those sub-components).
      </p>
      <sapia:note>
      You will see certain constructors taking a <sapia:classlink>org.sapia.ubik.util.Conf</sapia:classlink> instance as an argument: this allows passing properties
      which override system properties. In most cases though it is recommended to configure Ubik through properties defined for the whole JVM (that is, through
      system properties).
      </sapia:note>
    </sapia:sect2>
        
    <sapia:sect2 title="Group Communication" alias="groupcomm"> 
      <p>
        Ubik's robustness characteristics rely on group communication. Such group communication is based on the <sapia:classlink>org.sapia.ubik.mcast.EventChannel</sapia:classlink> class.
        As explained in the relevant <a href="group_communication.html#eventchannel">documentation</a>, the class supports unicast and broadcast communication. An <sapia:class>EventChannel</sapia:class>
        is used behind the scenes to coordinate communications between distributed JNDI nodes and smart stubs.
      </p> 
      <p>
        Therefore, the first thing that you must do when using Ubik is to set up the configuration of the event channel. The examples below show you how.
      </p>
		  <sapia:sect3 title="Default Setup: IP Multicast and TCP unicast">
			<p>
			  When creating an <sapia:channel>EventChannel</sapia:channel> with the constructor that takes only the domain name as argument, the channel will IP multicast for broadcast, and the
			  TCP <sapia:classlink>org.sapia.ubik.mcast.UnicastDispatcher</sapia:classlink> based on Apache Mina. The code below creates such an <sapia:class>EventChannel</sapia:class>:
			</p> 
			<sapia:code>
	EventChannel channel = new EventChannel("myDomain");
	channel.start();
			</sapia:code> 
		  </sapia:sect3>
	
		  <sapia:sect3 title="Customized EventChannel Setup">
			<p>
			  Of course, the setup can be customized. To use the <sapia:classlink>org.sapia.ubik.mcast.avis.AvisBroadcastDispatcher</sapia:classlink> 
			  (which depends on the Avis router and allows deploying broadcast over TCP), define the following system property:
			</p> 
			<sapia:code>
	ubik.rmi.naming.broadcast.provider=ubik.rmi.naming.broadcast.avis
			</sapia:code> 
			<p>
			  Then, instantiate the <sapia:class>EventChannel</sapia:class> as previously done:
			</p>
			<sapia:code>
	EventChannel channel = new EventChannel("myDomain");
	channel.start();
			</sapia:code> 
		  </sapia:sect3>
	
		  <sapia:sect3 title="Terminating an EventChannel">
			<p>
			  If your code has created an <sapia:class>EventChannel</sapia:class>, then it should also terminate it, as follows:
			</p> 
			<sapia:code>
	channel.close();
			</sapia:code> 
		  </sapia:sect3>
	 
	   	<sapia:sect3 title="Synchronous Remote Events">
		   	<p>
		   	  The <code>send</code> methods allow sending <sapia:class>RemoteEvent</sapia:class>s to one or more nodes, and expect a response from each of these
		   	  nodes in return. Events received in such a manner at the target nodes are thus dispatched to the <sapia:class>SyncEventListener</sapia:class> that is
		   	  listening to such events, at that node. The response is synchronously sent back to the <sapia:class>EventChannel</sapia:class> from which the 
		   	  <sapia:class>RemoteEvent</sapia:class> originated. That <sapia:class>EventChannel</sapia:class> is thus responsible for performing aggregation of the 
		   	  different responses, returning these to application code (i.e.: the code that initially invoked the <code>send</code> method).
		   	</p>
		   	<p>
		   	  The following snippets illustrate how to implement a <sapia:class>SyncEventListener</sapia:class>, and how to send <sapia:class>RemoteEvent</sapia:class>s
		   	  to it:
		   	</p>
		   	<sapia:code>
import org.sapia.ubik.mcast.*;

// firt implement the listener

public class MySyncEventListener implements SyncEventListener {
  public Object onSyncEvent(RemoteEvent evt) {
    return "WORLD";
  }
}

// register the listener with its EventChannel
// you must keep a reference on the listener, for the channel keeps
// those in weak references

listener = new MySyncEventListener();
recevingChannel.registerSyncListener("ubik.example.sync.event", listener);  

// now, on the other end, send the remote event and handle the response:

Response res = sendingChannel.send(remoteAddress, "ubik.example.sync.event", "HELLO");
if (res.isError()) {
  // handle error
} else if (res.getStatus() == Status.SUSPECT) {
  // remote node did not reply: probably down
} else {
  System.out.println(res.getData());
}
		   	</sapia:code>
	   
	      <sapia:note>Response timeout is managed globally, through the <tt>ubik.rmi.naming.mcast.response.timeout</tt> property.</sapia:note>	  
	   	</sapia:sect3>
	   	
      <sapia:sect3 title="Asynchronous Remote Events">
        <p>
          The <code>dispatch</code> methods in turn allow sending <sapia:class>RemoteEvent</sapia:class>s to all, one, or many nodes, asynchronously (no
          response is expected on this case). 
        </p>
        <p>
          Here's how  <sapia:class>AsyncEventListener</sapia:class>s are dealt with:
        </p>
        <sapia:code>
import org.sapia.ubik.mcast.*;

// firt implement the listener

public class MyAsyncEventListener implements AsyncEventListener {
  public void onAsyncEvent(RemoteEvent evt) {
    try {
      System.out.println("Received a remote event " + evt.getType() + ": " + evt.getData());      
    } catch (Exception e) {
      // deserialization of remote event data may throw IOExceptions and ClassNotFoundExceptions
      e.printStackTrace();
    }
  }
}
 
// register the listener with its EventChannel
listener = new MyAsyncEventListener();
recevingChannel.registerAsyncListener("ubik.example.async.event", listener);  
 
// on the other end, send the event
sendingChannel.dispatch("ubik.example.async.event", "HELLO");
        </sapia:code>
     
        <sapia:note><sapia:class>RemoteEvent</sapia:class>s received in the <tt>onAsyncEvent</tt> method should
        be handled in a separated thread, if processing risks blocking for too long.</sapia:note>    
      </sapia:sect3>
	    
	  </sapia:sect2>
	  
		<sapia:sect2 title="Distributed JNDI">
		  <p>To expose the smart stubs created by Ubik as remote services, you must use Ubik's distributed JNDI. 
		  The <sapia:classlink>org.sapia.ubik.rmi.naming.remote.EmbeddableJNDIServer</sapia:classlink>, as its name implies,
		  can be embedded in your application. An <sapia:class>EmbeddableJNDIServer</sapia:class> uses an 
		  <sapia:class>EventChannel</sapia:class> to discover other JNDI server nodes on the network. Alltogether, they form a distributed
		  JNDI tree across which smart stubs are replicated.
		  </p>
		  <sapia:sect3 title="Creating and Starting a JNDI Server">
		    <sapia:code>
EventChannel channel = new EventChannel("myDomain"); 
channel.start();
EmbeddableJNDIServer jndi = new EmbeddableJndiServer(channel.getReference(), 1099);
jndi.start(true); // true: server will start as daemon

// when done:
jndi.stop();
channel.close();
		    </sapia:code>
		  </sapia:sect3>
		  
      <sapia:sect3 title="Binding a Remote Object">
        <p>If you use an <sapia:class>EmbeddableJNDIServer</sapia:class> directly in your application, you can bind a remote object to it as such:</p>
        <sapia:code>
MyService stub = Hub.export(myService);
jndi.getLocalContext().bind("services/myService", stub);
        </sapia:code>
        <p>If you connect to an <sapia:class>EmbeddableJNDIServer</sapia:class> remotely, do as follows (of course use the appropriate port):</p>
        <sapia:code>
Properties props = new Properties();
props.setProperty(InitialContext.PROVIDER_URL, "ubik://localhost:1099/");
props.setProperty(InitialContext.INITIAL_CONTEXT_FACTORY, RemoteInitialContextFactory.class.getName());
InitialContext ctx = new InitialContext(props);
MyService stub = Hub.export(myService);
ctx.bind("services/myService", stub);
        </sapia:code>
      </sapia:sect3>		  
		  
      <sapia:sect3 title="Looking up a Remote Object">
        <p>If you use an <sapia:class>EmbeddableJNDIServer</sapia:class> directly in your application, you can bind a remote object to it as such:</p>
        <sapia:code>
MyService stub = (MyService) jndi.getLocalContext().lookup("services/myService");
        </sapia:code>
        <p>If you connect to an JNDI server remotely, do as follows (of course use the appropriate port):</p>
        <sapia:code>
Properties props = new Properties();
props.setProperty(InitialContext.PROVIDER_URL, "ubik://10.10.10.11:1099/");
props.setProperty(InitialContext.INITIAL_CONTEXT_FACTORY, RemoteInitialContextFactory.class.getName());
InitialContext ctx = new InitialContext(props);
MyService stub = (MyService) ctx.lookup("services/myService");
        </sapia:code>
      </sapia:sect3>  		  
		  
      <sapia:sect3 title="Resilient Lookup">
        <p>
          When connecting to a JNDI server remotely, the address of the host (and/or its port) may be misconfigured, or the host to which
          you're attempting to connect may not be up. In this context, it is possible to help the 
          <sapia:classlink>org.sapia.ubik.rmi.naming.remote.RemoteInitialContextFactory</sapia:classlink> connect to another existing JNDI server.
          To that end, you must specify the <tt>ubik.jndi.domain</tt> property, either as a system property, or as a property you pass to the
          <sapia:class>InitialContext</sapia:class>. The above example sets that property (by using the corresponding constant of the 
          <sapia:class>RemoteInitialContextFactory</sapia:class>):          
        </p>
        
        <sapia:code>
Properties props = new Properties();
props.setProperty(RemoteInitialContextFactory.UBIK_DOMAIN_NAME, "default");
props.setProperty(InitialContext.PROVIDER_URL, "ubik://localhost:1098");
props.setProperty(InitialContext.INITIAL_CONTEXT_FACTORY, RemoteInitialContextFactory.class.getName()); 
        </sapia:code>
        
        <p>
          Internally, the <sapia:class>RemoteInitialContextFactory</sapia:class> instance will create an <sapia:class>EventChannel</sapia:class>.
        </p>
        
      </sapia:sect3>  
		  
      <sapia:sect3 title="Discovery">
        <p>It may be that the order in which distributed nodes appear on the network is not necessarily guaranteed. It then may also be
        that application nodes exporting services on which other nodes depend may not yet be present on the network, as these other nodes themselves
        start up. This is also true for JNDI server nodes: a client my appear on the network, and attempt connecting on a JNDI server that isn't yet
        on the network.</p>
        
        <p>To work around these situations, use a <sapia:classlink>org.sapia.ubik.rmi.naming.remote.discovery.DiscoveryHelper</sapia:classlink> 
        instance, to which you can register a <sapia:classlink>org.sapia.ubik.rmi.naming.remote.discovery.ServiceDiscoListener</sapia:classlink>
        (for discovering services that appear on the network), or a <sapia:classlink>org.sapia.ubik.rmi.naming.remote.discovery.JndiDiscolistener</sapia:classlink>
        (for discovering JNDI servers).</p>
        
        <p>The following snippet illustrates usage of a <sapia:class>DiscoveryHelper</sapia:class> to find appearing JNDI servers, and bind to a discoverd server 
        a remote object so that it has a copy of the stub, which is then available to clients wishing to use the service:</p>
        
        <sapia:code>
EventChannel    channel     = new EventChannel("myDomain");
DiscoveryHelper discoHelper = new DiscoveryHelper(channel.getReference());
discoHelper.addJndiDiscoListener(new JndiDiscoListener() {
  @Override
  public void onJndiDiscovered(Context ctx) {
    ctx.bind("services/myService", remoteObject);
  }
});
        </sapia:code>
        
        <p>The following demonstrates how to discover services:</p>
        
        <sapia:code>
EventChannel    channel     = new EventChannel("myDomain");
DiscoveryHelper discoHelper = new DiscoveryHelper(channel.getReference());
discoHelper.addServiceDiscoListener(new ServiceDiscoListener() {
  @Override
  public void onServiceDiscovered(ServiceDiscoveryEvent evt) {
    System.out.println("Discovered service: " + evt);
  }
});
        </sapia:code>
        
      </sapia:sect3>    
		  
		</sapia:sect2>

  </sapia:sect1>

</sapia:page>
