<sapia:page title="Soto State Machine" xmlns:sapia="http://www.sapia-oss.org/2003/XSL/Transform">
  <sapia:vmenu>
    <sapia:vsection name="Project Home" href="index.html"/>
    <sapia:vsection name="Javadoc" href="maven/api/index.html"/>
    <sapia:vsection name="Maven" href="maven/index.html"/>
  </sapia:vmenu>
  <sapia:sect1 title="State Machine API">
    <sapia:section>
      <sapia:path name="home" href="http://www.sapia-oss.org" />
      <sapia:path name="projects" />
      <sapia:path name="soto" href="../../index.html" />
      <sapia:path name="state machine"/>      
    </sapia:section>
    
    <toc/>

    <sapia:sect2 title="Overview">
      <sect-desc>
        <p>This API offers a powerful way to quickly implement state machines. The logic contained
        in states can seamlessly be integrated into Soto's configuration, and have access to configured Soto
        service implementations - through service references (assigned with the <sapia:command>soto:serviceRef</sapia:command>
	tag).</p>
        
        <p>State machines should be used when an application is composed of interdependent blocks of
        actions, whose execution order varies according to some application-specific
        parameters and business rules. The more there are actions and execution parameters, the more 
	complex an application becomes. State-based behavior is very often wrongly implemented as blobs of sequential
        and nested if/else blocks in compiled code; state machines can greatly help reduce complexity in such cases.</p>
	
	<p>In addition, STM(State Machine API) is convenient in situations where incoming requests (in all forms) have to be wired to a
	backend, and where request handling logic rests upon actions/steps that change often; in such cases a compiled
	language such as Java is ill-suited - yes, Java is compiled, even though its bytecode is interpreted...</p>
	
	<p>STM sports the following features/characteristics:</p>
	
	<ul>
	  <li>Allows extracting coarse-grained conditional switching logic from Java code.</li>
	  <li>supports subdiving state machines in "modules";</li>
	  <li>supports auto-reloading of modified module configuration (very neat for RAD);</li>
          <li>customizable: implement your own tags;</li>
	  <li>fully integrated with Soto: service references can be assigned to state instances through
	  configuration;</li>
	  <li>supports Groovy compiled scripts; together with module auto-reloading, spares recompilation/redeployments
	  when code changes (very neat for RAD);</li>
	  <li>integrates well with existing MVC frameworks;</li>
	  <li>complements XML-based "small languages" used to define business rules and execution flows in a declarative,
	  high-level fashion (such as BPEL).</li>
	</ul>
        
        <p>Without further ado, the following delves into the specifics of using the API.</p>
	
	<sapia:note>The STM tags not explained in this page can be found in the <a href="doc/StmTagReference.pdf">STM tag reference</a></sapia:note>
        
      </sect-desc>
    </sapia:sect2>
    
    <sapia:sect2 title="Concepts">
      <sect-desc>
        <p>The API is designed around the following key concepts - each with a corresponding class:</p>
      </sect-desc>
    
      <p>
        <ul><li>
        <sapia:class link="maven/api/org/sapia/soto/state/StateMachine.html">State Machine</sapia:class>: 
        a state machine embeds states that correspond to some actions to execute. Client applications trigger 
        a given state's execution by passing its identifier to the state machine, as well as an execution
        <sapia:class link="maven/api/org/sapia/soto/state/Context.html">Context</sapia:class> that holds various
        execution parameters - saying that a state is executed might sound strange: a state is by definition 
        static, how could it "do" something? Well, let's say it the other way then: some action is triggered 
        when the application is in a given state.</li>

        <li><sapia:class link="maven/api/org/sapia/soto/state/State.html">State</sapia:class>: a state contains executable
        logic. It is provided with the current execution context, on which it can act. It can also trigger the execution 
        of a "next" state, or signal an error.</li>

        <li><sapia:class link="maven/api/org/sapia/soto/state/Step.html">Step</sapia:class>: A state can contain complex 
        logic; multiple actions can be performed in the context of a state. These actions are "steps". A step is an
        atomic unit of work.</li>

        <li><sapia:class link="maven/api/org/sapia/soto/state/Result.html">Result</sapia:class>: once a state (or a series
        of states) has been executed, the application is provided with an execution result. The result can contain an
        error - if any state as signaled one; if it holds no error, then successful execution is assumed.</li>
        </ul>
      </p>

    </sapia:sect2>
    <sapia:sect2 title="Design">
      
      <sapia:sect3 title="States and Steps" >
 
      <p>Both <sapia:class>State</sapia:class>s and <sapia:class>Step</sapia:class>s are instances of 
	the <sapia:class link="maven/api/org/sapia/soto/state/Executable.html">Executable</sapia:class>
	interface; the latter's signature goes as follows:</p>
<sapia:code>
public interface Executable{
 
  public void execute(Result res); 
 
}</sapia:code>

     <p>Despite inheriting from the same interface, the <sapia:class>State</sapia:class> and <sapia:class>Step</sapia:class> 
     interfaces are conceptually different: a step is an atomic unit of work in the context of a state. The 
     <sapia:class>State</sapia:class> interface in addition specifies the following method:</p>
<sapia:code>
public interface State extends Executable{
 
  public String getId(); 
 
}</sapia:code>

      <p>Indeed, a state must return an identifier that is unique in the scope of a state machine. Client applications
      trigger a state's execution by calling the <sapia:command>execute()</sapia:command> method on a 
      <sapia:class>StateMachine</sapia:class> instance, passing in the unique identifier of the state to execute,
      as well as a <sapia:class link="maven/api/org/sapia/soto/state/Context.html">Context</sapia:class> instance that
      is exclusive to the execution thread.</p>

      <p>As you can see, no method on the <sapia:class>State</sapia:class> interface indicates that steps can be added;
      this is simply in order not to force states into being composed of steps. The 
	<sapia:class link="maven/api/org/sapia/soto/state/StepState.html">StepState</sapia:class> class can be used to conveniently
      implement states that are composed of steps.</p>

      </sapia:sect3>

      <sapia:sect3 title="Execution">
        <p>As was mentioned, a state's execution is first triggered by a client application; yet, a state can also trigger the
        execution of another state, by indication the identifier of the next state to execute. It can also signal that an error
        has occurred:</p>
<sapia:code>
public class FirstState implements State{
  ...
  public void execute(Result res){
    try{
      // do something
      res.setNextStateId("secondState");
    }catch(Exception e){
      res.error("Problem executing state: " + getId(), e);
     
      // this is important since we do not want to continue
      // if a problem as occurred.
      return;
    }
  }
  ...
}</sapia:code>
        <p>After each state's execution, the state machine will introspect the <sapia:class>Result</sapia:class>
        instance and do one of the following:
        </p>
        <ul>
          <li>If the identifier of a "next state" to execute has been set AND no error has been signaled,
          the state machine goes on to the next state;</li>

          <li>if no "next state" has been specified and no error has been signaled, then execution is deemed complete
          and the <sapia:class>Result</sapia:class> instance is returned to the calling application.</li>

          <li>if an error has been signaled and no "next state" has been specified, a 
          <sapia:class link="maven/api/org/sapia/soto/state/StateExecException.html">StateExecException</sapia:class> is
          thrown, unless the error has already been "handled" - see next section;</li>

        </ul>
      </sapia:sect3>
      <sapia:sect3 title="Result Token" alias="resultToken">
        <p>A <sapia:class link="maven/api/org/sapia/soto/state/Result.html">Result</sapia:class> instant holds a 
        <sapia:class link="maven/api/org/sapia/soto/state/ResultToken.html">ResultToken</sapia:class> instance,
        whose value can be set, and later on tested, to affect the execution flow. This can conveniently be used in
        conjunction with <a href="#actionSteps"><sapia:class>ActionStep</sapia:class></a> and 
        <a href="#branchTag"><sapia:command>stm:branch</sapia:command></a>
        tags.
        </p>
      </sapia:sect3>
	<sapia:sect3 title="Error Handling">
	  <p>In some cases, it might be that you do not want <sapia:class>StateExecException</sapia:class>s being thrown
        when errors are signaled; you'd rather delegate the handling of the error to a specialized state. For example,
        consider the following classes:</p>
<sapia:code>
public class FirstState implements State{
  ...
  public void execute(Result res){
    try{
      // do something
      res.setNextStateId("secondState");
    }catch(Exception e){
      res.error("Problem executing state: " + getId(), e);

      // Here we set the id of the next state to execute;
      // for this example, we suppose that it is an
      // ErrorState instance - see class below.
      res.setNextStateId("handleError");

      // this is important since we do not want to continue
      // if a problem as occurred.
      return;
    }
  }
  ...
}</sapia:code>

        <p>And then:</p>

<sapia:code>
public class ErrorState implements State{
  ...
  public void execute(Result res){
    Err err = res.handleError();
    System.out.println("An error occured: " + err.getMsg());
    System.out.println(err.getThrowableAsString());
  }
  ...
}</sapia:code>

        <p>Note the call to the <sapia:command>handleError()</sapia:command>; it returns
        the <sapia:class link="maven/api/org/sapia/soto/state/Err.html">Err</sapia:class>
        instance encapsulating error information, but also sets an internal flag that eventually
        indicates to the state machine that the error has cleanly been handled and that no
        exception needs being thrown.</p>

      </sapia:sect3>

    </sapia:sect2>

    <sapia:sect2 title="Usage">
      <p>The <sapia:class>StateMachine</sapia:class> class implements the 
      <sapia:class link="maven/api/org/sapia/soto/Service.html">Service</sapia:class> interface; 
      an instance of the class can thus be configured as part of a Soto container's configuration. 
      <sapia:class>State</sapia:class> and <sapia:class>Step</sapia:class> implementations can also 
      be configured as part of a Soto configuration file, provided their corresponding 
      object definitions have been declared.</p>

      <sapia:note>The above might sound weird to you if you have not read about 
      <a href="../index.html" target="soto_basics_window">Soto's basics</a>.</sapia:note>

      <p>To better illustrate what we mean, here is a configuration that would correspond to
      the states that we have implemented previously:</p>

<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:stm="soto:stm"
          xmlns:example="soto:example">


  <soto:namespace prefix="example">
    <def class="org.sapia.soto.state.example.ErrorState"  
         name="error" />  
    <def class="org.sapia.soto.state.example.FirstState"  
         name="first" />  
    <def class="org.sapia.soto.state.example.SecondState" 
         name="second" />  
  </soto:namespace>

  <soto:service id="stateMachine/example">
    <stm:machine>
      <stm:states>
        <example:first  id="firstState" />
        <example:second id="secondState" />
        <example:error  id="handleError" />
      </stm:states>
    </stm:machine>
  </soto:service>
  
</soto:app>]]></sapia:code>    

      <p>The <sapia:command>stm:machine</sapia:command> element corresponds to the
      <sapia:class link="maven/api/org/sapia/soto/state/StateMachineService.html">StateMachineService</sapia:class>
      class. It can contain one to many <sapia:command>stm:states</sapia:command> element(s), each
      corresponding to a <sapia:class>StateMachine</sapia:class> instance - if more than one
      <sapia:command>stm:states</sapia:command> element is defined, they are merged into the same state
      machine in memory. A state machine can take one to many states (in the configuration, states must be 
      declared under the <sapia:command>stm:states</sapia:command> element). All states must have a unique identifier
      in the scope of the state machine. Once a state machine has been defined, it
      can be loaded into a <sapia:class>SotoContainer</sapia:class> instance:</p>

<sapia:code>
...
SotoContainer container = new SotoContainer();
container.start();
StateMachineService machine = 
  (StateMachineService)container.lookup("stateMachine/example");
Result res = machine.execute("first", new ContextImpl());
...</sapia:code>
    </sapia:sect2>

    <sapia:sect2 title="Advanced Issues">

      <sapia:sect3 title="Using the StepState class">

        <p>The <sapia:class link="maven/api/org/sapia/soto/state/StepState.html">StepState</sapia:class>
	class implements the <sapia:class>State</sapia:class> interface and inherits from the 
        <sapia:class link="maven/api/org/sapia/soto/state/ExecContainer.html">ExecContainer</sapia:class> class. 
        The latter aggregates <sapia:class>Executable</sapia:class> instances. The <sapia:class>StepState</sapia:class> 
        class builds on that behavior and accepts <sapia:class>Step</sapia:class> instances. If you look 
        closely at the <sapia:class>ExecContainer</sapia:class> class, it specifies 
        <sapia:command>handleSuccess()</sapia:command> and <sapia:command>handleError()</sapia:command> methods. 
        These methods are overridden by the <sapia:class>StepState</sapia:class> class to redirect to a "success" or an
        "error" state, accordingly. You can see that the class also has <sapia:command>setSuccess(...)</sapia:command> and 
        <sapia:command>setError(...)</sapia:command> methods, that take the identifier of the states to execute in the 
        case of success or failure, respectively. 
        </p>
         
        <p>The execution algorithm (implemented by the <sapia:class>ExecContainer</sapia:class>) class goes as follows:</p>

<sapia:code>
forEach step in steps
  execute step
  if error
    handleError
    return
  else if abort
    return
  end if
end forEach
handleSuccess
</sapia:code>

        <p>The <sapia:class>StepState</sapia:class> overrides the <sapia:command>handleSuccess()</sapia:command> and 
        <sapia:command>handleError()</sapia:command> methods by setting to the <sapia:class>Result</sapia:class> 
        instance the identifier of the "next state" to execute (either the success or error state, in this case).</p> 

        <p>In reality, the <sapia:class>StepState</sapia:class> instance can be used at large to implement states,
        and that is most of the time the only class you will use. What you will do, rather, is to implement 
        <sapia:class>Step</sapia:class> instances.</p>

        <p>In the configuration, a <sapia:class>StepState</sapia:class> is declared with a 
        <sapia:command>machine:state</sapia:command> element; then you specify the identifiers of the success and error
        states, and declare your steps as child elements. Here is an example:</p>

<sapia:code><![CDATA[<stm:state id="checkinShoppingCart" error="displayError">

  <example:checkInventory />
  <example:buyItems />
  <example:handleCreditCard />

</stm:state>

<example:err id="displayError" />]]></sapia:code>    
 
        <p>As you can see, no "success" attribute was specified on the <sapia:command>machine:state</sapia:command>
	element; in this case, control returns to the application if no error occurs after the state's execution.</p>

      </sapia:sect3>
      
      <sapia:sect3 title="Contexts and Scopes">
        <p>We have seen the <sapia:class link="maven/api/org/sapia/soto/state/Context.html">Context</sapia:class>
        interface. An instance of the latter is simply meant to hold data passed in by the application. A 
        <sapia:class>Context</sapia:class> behaves a bit like a <sapia:class>Map</sapia:class>: values can be
        looked up from it using names - thus a context holds name/value bindings.</p>

        <p>To be more precise, we should say that a context has "scopes"; that is: values are internally bound to
        a name, within a specific scope. For example, suppose that we create a <sapia:class>Context</sapia:class>
        implementation to be used in a servlet; we could have a request scope, a session scope and so on. Scopes
        are identified with a name, and so values can be looked up in a context by specifying not only the name
        of the desired value, but also the scope to which the value belongs. If you look at the 
        <sapia:class>Context</sapia:class> class more closely, you will indeed see that it allows to retrieve values
        for a given scope, or for a given list of scopes.</p>

        <p>The notion of scope is quite important: a scope might "live" for the duration of  a request, another could 
        be global and live for the duration of an application. The scope concept is modeled by the 
        <sapia:class link="maven/api/org/sapia/soto/state/Scope.html">Scope</sapia:class> interface. The 
        <sapia:class link="maven/api/org/sapia/soto/state/ContextImpl.html">ContextImpl</sapia:class> allows to add
        <sapia:class>Scope</sapia:class>s. A convenient implementation of the <sapia:class>Scope</sapia:class>
        interface is the <sapia:class link="maven/api/org/sapia/soto/state/MapScope.html">MapScope</sapia:class> class, 
        that simply implements its behavior over a <sapia:class>java.util.Map</sapia:class>.</p>

        <p>Here is an example:</p>

<sapia:code>
MapScope scope = new MapScope();
scope.put("salutation", "Hello World");
ContextImpl ctx = new ContextImpl();
ctx.addScope("example", scope);

// Now we can look up...

System.out.println(ctx.get("salutation"));

System.out.println(ctx.get("salutation", "example"));</sapia:code>

        <p>The example above shows how to create a context, and then how to perform lookups; we can see that a value
        can be looked up by specifying a scope, or no scope at all. If no scope is specified, then all scopes are searched, 
        until a value is found. If no value is found, then null is return.</p>
	
        <sapia:note>The notion of scope is quite handy if one whishes to use STM with existing MVC/webapp frameworks:
	you can have "request", "session", "application", etc., scopes.</sapia:note>	

        <p>In addition to the map-style behavior, the <sapia:class>Context</sapia:class> class offers stack 
        functionality: values can be pushed to and popped from a context; this is convenient and allows to pass
        data from step to step, or from state to state. In a MVC framework for example, the model could be
        pushed on the stack, and then retrieved from the stack in a "view" state.</p>
       
        <sapia:note>A <sapia:class>Context</sapia:class> instance must be discarded after execution.</sapia:note>
 
      </sapia:sect3>
      
      <sapia:sect3 title="Using the ActionStep class" alias="actionSteps">

        <p>
          The <sapia:class link="maven/api/org/sapia/soto/state/util/ActionStep.html">ActionStep</sapia:class> allows mapping
          the <sapia:command>execute()</sapia:command> method to an arbitrary "normal" method. That is:
          
          <ul>
            <li>One inherits the <sapia:class>ActionStep</sapia:class> class and implements the desired method(s).</li>
            <li>Then an object definition (XML tag) is created for the step class.</li>
            <li>The step class can be use in a state machine; the method to call on the step is specified through configuration.</li>
          </ul>
        </p>
        <p>
          For a better understanding, here is a step by step example, by implementing an authentication step:
        </p>
        <sapia:sect4 title="Inherit from the ActionStep class">
<sapia:code>
import org.sapia.soto.state.util.ActionStep;

public class AuthenticationStep extends ActionStep{

  public void authenticate(String username, String password) 
    throws AuthenticationException{
    // here we would write authentication code...
  }
}
</sapia:code>
          <p>In the above, we need not worry about the framework (the execution context and so on...). We write
          a class with "normal" methods that do not depend on classes from the STM API in their signature.</p>
          <sapia:note>
            Note that you can put as many methods as you want in your class. You map in the configuration which
            method the <sapia:command>execute()</sapia:command> method will invoke - see further below. 
          </sapia:note>
        </sapia:sect4>
        
        <sapia:sect4 title="Create an object definition">
          <p>To be able to use the implementation in a STM configuration, we need to write an object 
          definition for it:
          </p>
          
<sapia:code><![CDATA[...
  <soto:namespace prefix="example">
    <def class="org.myapp.stm.AuthenticationStep"  
         name="authenticate" />  
  </soto:namespace>
...]]></sapia:code>    
        </sapia:sect4>

        <sapia:sect4 title="Use the step in a state machine configuration">
          <p>
            
          </p>
          
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:stm="soto:stm"
          xmlns:example="soto:example">

  <soto:namespace prefix="example">
    <def class="org.myapp.stm.AuthenticationStep"  
         name="authenticate" />  
  </soto:namespace>

  <soto:service id="stateMachine/example">
    <stm:machine>
      <stm:states>
        <stm:state id="performAuthentication">
          <example:authenticate>
            <method name="authenticate">
              <param><stm:value key="username:params" /></param>
              <param><stm:value key="password:params" /></param>
            </method>
          </example:authenticate>
        </stm:state>
      </stm:states>
    </stm:machine>
  </soto:service>
  
</soto:app>]]></sapia:code>    
          
          <p>Now, this is where it gets interesting:
            <ul>
              <li>The method to invoke is specified through a <sapia:command>method</sapia:command>
              element.</li>
              <li>The parameters to pass to the method are in turn specified through <sapia:command>param</sapia:command>
              elements.</li>
              <li>The value of a parameter must correspond to an XML element that evaluates to an object that corresponds
              to the method's signature. In addition, the <sapia:command>stm:value</sapia:command> tag can be used to
              pass objects that are acquired from the execution context - more on that below.</li>
            </ul>
          </p>
          
          <p>
            The <sapia:command>stm:value</sapia:command> tag allows retrieving values from the execution context. The tag 
            takes a <sapia:command>key</sapia:command> element or attribute that takes the key and scope of an expected object in the context
            that should be passed as a parameter to the indicated method. The key and scope are delimited by a colon. 
            The scope part is optional (if not specified, all scopes are searched), and can in addition consist of a coma-delimited 
            list - in such a case, the scopes will be searched in the order in which they are specified in the list.
          </p>
          
          <p>
            Usage of the <sapia:command>stm:value</sapia:command> tag is not mandatory; any tag that evaluates to an object matching
            the corresponding parameter in the method could be passed in, such as a reference to a previously configured service:  
          </p>
          
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:stm="soto:stm"
          xmlns:example="soto:example">
  ...
    <method name="doSomething">
      <param><soto:serviceRef id="someService" /></param>
    </method>
  ...  
</soto:app>]]></sapia:code>    

          <p>In fact, the <sapia:command>stm:value</sapia:command> evaluates to an instance of 
          <sapia:class link="maven/api/org/sapia/soto/state/StmKey.html">StmKey</sapia:class> class,
          which is treated specially by the <sapia:class>ActionStep</sapia:class>: the return value of the 
          <sapia:command>lookup()</sapia:command> method of the <sapia:class>StmKey</sapia:class> is passed as a value for
          the corresponding parameter.
          </p>
          
          <p>
            Using the <sapia:class>ActionStep</sapia:class> class in conjunction with the <sapia:command>stm:value</sapia:command>
            tag is a nice way to seamlessly integrate STM with plain Java objects.
          </p>
                    
        </sapia:sect4>
        <sapia:sect4 title="Advanced Tips">
          <sapia:sect5 title="Return Values">
          <p>Methods that are called through an <sapia:class>ActionStep</sapia:class> can return values (they do not have
          to return void. By default, if such a method returns a value, it is pushed on the execution context stack, and can
          be retrieved through the <sapia:command>currentObject()</sapia:command> method of the context.
          </p>
          <p>If the return value is not to be pushed on the context, then the <sapia:command>push</sapia:command> attribute
          of the corresponding <sapia:command>method</sapia:command> can have its value set to false:</p>
          
<sapia:code><![CDATA[<soto:app xmlns:soto="sapia:soto"
          xmlns:stm="soto:stm"h
  ...
    <method name="doSomething">
      <param><soto:serviceRef id="someService" /></param>
    </method>
  ...  
</soto:app>]]></sapia:code>              
          </sapia:sect5>
          <sapia:sect5 title="Special Parameters">
            <p><sapia:class>ActionStep</sapia:class> methods can have special parameters that do not require a
            <sapia:command>param</sapia:command> element specified. When analyzing methods at intialization time, the 
            <sapia:class>ActionStep</sapia:class> determines if methods have parameters of the following type:</p>  
          
            <ul>
              <li><sapia:class link="maven/api/org/sapia/soto/state/Result.html">Result</sapia:class></li>
              <li><sapia:class link="maven/api/org/sapia/soto/state/Context.html">Context</sapia:class></li>
            </ul>
            
            <p>If that is the case, the current <sapia:class>Result</sapia:class> and/or <sapia:class>Context</sapia:class>
              is passed to the methods at runtime. For example, given our modified authentication step below:
            </p>
<sapia:code>
import org.sapia.soto.state.util.ActionStep;

public class AuthenticationStep extends ActionStep{

  public void authenticate(String username, 
                           String password, 
                           Result res) 
    throws AuthenticationException{
    // here we would write authentication code...
  }
}
</sapia:code>
            <p>Our configuration would not have to be modified (the <sapia:class>Result</sapia:class> 
            instance expected by the method is automatically passed in at runtime):</p>
            
            
<sapia:code><![CDATA[<stm:state id="performAuthentication">
  <example:authenticate>
    <method name="authenticate">
      <param><stm:value key="username:params" /></param>
      <param><stm:value key="password:params" /></param>
    </method>
  </example:authenticate>
</stm:state>]]></sapia:code>    
            
          </sapia:sect5>
          <sapia:sect5 title="Result Tokens">
            <p><sapia:class>ActionStep</sapia:class> methods can conveniently be
            used with the result token feature, allowing branching based on
            the token's value:</p>
<sapia:code>
import org.sapia.soto.state.util.ActionStep;
import org.sapia.soto.state.ResultToken;

public class AuthenticationStep extends ActionStep{
   
  public static final String AUTH_FAILURE = "AUTH_FAILURE";

  public void authenticate(String username, 
                           String password, 
                           Result res) {
    try{
      ...
      res.getToken().setValue(ResultToken.OK);
    }catch(AuthenticationException e){
      res.getToken().setValue(AUTH_FAILURE);
    }
  }
}
</sapia:code>          
          </sapia:sect5>          
          <p>Branching can occur after the method's execution, based on the
          value of the result token - see next section.</p>
        </sapia:sect4>
      </sapia:sect3>
      
      <sapia:sect3 title="Conditions">
        <p>The Soto State Machine API comes built in with <sapia:class>Step</sapia:class> implementations that perform
        conditional branching. The implementations respect a common pattern: they expect nested steps that will
        be executed only if a given boolean expression is true. Some implementations use 
        <a href="http://jakarta.apache.org/commons/sandbox/jexl/" target="jexl_window">Jexl</a> to evaluate the provided expressions. This
        is to say that they must respect the Jexl syntax.</p>
        
        <sapia:sect4 title="Branch" alias="branchTag">
          <p>The <sapia:command>stm:branch</sapia:command> tag allows performing control flow based on the value of the
          result token (as explained in a <a href="#resultToken">previous section</a>). It supports multiple conditions - and branches at the first condition that evaluates to true:</p>

<sapia:code><![CDATA[<stm:branch>
  <when token="OK">
    <example:echo msg="success" />
  </when>
  <when token="AUTH_FAILURE">
    <example:echo msg="Invalid username or password" />
  </when>
  <when token="SYSTEM_ERROR">
    <example:echo msg="System error." />
  </when>
  <otherwise>
    <example:echo msg="Unknown problem." />
  </otherwise>
</stm:branch>]]></sapia:code>

        </sapia:sect4>
        
        
        <sapia:sect4 title="If" >
          <p>The <sapia:command>stm:if</sapia:command> element branches into its nested steps provided the
          conditional expression it specifies evaluates to <sapia:command>true</sapia:command>. The expression
          is internally evaluated against a value in the context, or against the current object on the context stack.</p>

          <p>The example below tests if a given value exists in the context (based on its name):</p>

<sapia:code><![CDATA[<stm:if test="firstName != null">

  ...

</stm:if>]]></sapia:code>

          <p>A comma delimited list of scopes, can be specified - the expected value will be searched in the specified
          scopes, in their respective order:</p>

<sapia:code><![CDATA[<stm:if test="firstName != null" scopes="request, session">

  ...

</stm:if>]]></sapia:code>

	  <p>The expression can be a more complex one:</p>

<sapia:code><![CDATA[<stm:if test="firstName != null && firstName.length() == 0" 
    scopes="request, session">

  ...

</stm:if>]]></sapia:code>


        </sapia:sect4>

        <sapia:sect4 title="Choose" >
          <p>The <sapia:command>stm:choose</sapia:command> is similar to the "if", except that it supports multiple 
             conditions - and branches at the first condition that evaluates to true:</p>

<sapia:code><![CDATA[<stm:choose>
  <when test="User.language() == 'fr'" scopes="session">
    <example:echo msg="Bonjour" />
  </when>
  <when test="User.language() == 'de'" scopes="session">
    <example:echo msg="Guten Tag" />
  </when>
  <when test="User.language() == 'it'" scopes="session">
    <example:echo msg="Buongiorno" />
  </when>
  <otherwise>
    <example:echo msg="Hello" />
  </otherwise>
</stm:choose>]]></sapia:code>

        </sapia:sect4>
        
        <sapia:sect4 title="Useful Tip">
          <p>The <sapia:class>ContextImpl</sapia:class> class implements a special scope, the 
          "context" scope. That scope allows retrieving the current object on the execution
          context stack, through scope access. Thus the following:
          </p>
<sapia:code>
current = context.currentObject();
</sapia:code>
          <p>... is equivalent to:</p>
<sapia:code>
current = context.get("currentObject", "context");
</sapia:code>          
          <p>This thus means that the following would be consistent and valid:</p>
<sapia:code><![CDATA[<stm:if test="currentObject.role == 'superadmin'" 
        scopes="context">

  ...

</stm:if>]]></sapia:code>
          <p>This is convenient in cases where conditional branching is to be done
          based on the current object on the execution stack. </p>
        </sapia:sect4>

      </sapia:sect3>
      <sapia:sect3 title="Inlining Groovy Code">
        <p>The <sapia:command>stm:groovy</sapia:command> element corresponds to a step implementation that allows to 
        embed <a href="http://groovy.codehaus.org/" target="groovy_window">Groovy</a> snippets straight into the XML configuration. 
        The code is compiled at load time. Here's an example:</p>

<sapia:code><![CDATA[<stm:groovy>
  System.out.println("Hello World");
</stm:groovy>]]></sapia:code>

	<p>The Groovy code has access to the <sapia:class>Result</sapia:class> that is passed to the step's 
        <sapia:command>execute()</sapia:command> method. The instance is accessible through the "result" variable:</p>

<sapia:code><![CDATA[<stm:groovy>
  // here do something...
  result.setNextStateId("someState");
</stm:groovy>]]></sapia:code>

        <p>See Groovy's documentation for more information.</p>
				
				<sapia:note>STM integrates numerous other scripting languages; have a look at the Tag Reference for mode details</sapia:note>

      </sapia:sect3>
      <sapia:sect3 title="State Interceptors">
        <p>It is possible to apply interceptor to states: prior to executing a given state, it might be necessary to trigger
        the execution of other states - or to do so after a state's execution, or both. Thus, given states become 
        interceptors for other states. The configuraton below clearly illustrates how this is possible:</p>


<sapia:code><![CDATA[...
<example:debug id="before">
  <!-- steps to perform -->
  <example:displayEnter />
  <example:startTimer />
</example:debug>

<example:debug id="after">
  <!-- steps to perform -->
  <example:displayExit />
  <example:endTimer />
</example:debug>

<stm:state id="checkInventory">
  <!-- steps here -->
</stm:state>

<stm:state id="makePayment">
  <!-- steps here -->
</stm:state>

<stm:interceptor preExec="before, checkInventory" 
                 postExec="after, makePayment">
  <example:checkoutShoppingCart id="doCheckout" />
</stm:interceptor>
...]]></sapia:code>

        <p>The <sapia:command>stm:interceptor</sapia:command> element allows to specify states that are to be executed
        prior and/or after a given state's execution. "Pre-executed" and "post-executed" states are specified with the
        <sapia:command>preExec</sapia:command> and <sapia:command>postExec</sapia:command> attributes respectively.</p>

        <p>The <sapia:command>stm:interceptor</sapia:command> element takes a single child element - which must be a 
           state.</p>
     
      </sapia:sect3>
      <sapia:sect3 title="Global Steps">

       <p>There is another way to trigger pre-execution and post-execution that can be more convenient when what needs
       to be pre-executed or post-executed are steps. In such a case, it is possible to declare global steps, to
       specify if they must be pre-executed or post-executed, and to specify, through a pattern-matching notation, to
       which states they apply. The example below demonstrates this:</p>

<sapia:code><![CDATA[...
<stm:globals>
  <preExec>
    <include id="do*"> 

    <!-- steps... -->
    <example:displayEnter />
    <example:startTimer />
  </preExec>
  <postExec>
    <include id="do*"> 

    <!-- steps... -->
    <example:displayExit />
    <example:endTimer />
  </postExec>
</stm:globals>

<stm:state id="checkInventory">
  <!-- steps here -->
</stm:state>

<stm:state id="makePayment">
  <!-- steps here -->
</stm:state>


<stm:interceptor preExec="checkInventory" 
                 postExec="makePayment">
  <example:checkoutShoppingCart id="doCheckout" />
</stm:interceptor>
...]]></sapia:code>

       <p>To apply steps to multiple states, simply declare them in a <sapia:command>stm:globals</sapia:command> element.
       The following describes how the element is used:</p>

       <ul>
         <li>It must be declared under the <sapia:command>stm:states</sapia:command> element;</li>
         <li>the <sapia:command>stm:globals</sapia:command> element can contain multiple 
         <sapia:command>preExec</sapia:command> and <sapia:command>postExec</sapia:command> elements;</li>
         <li><sapia:command>preExec</sapia:command> and <sapia:command>postExec</sapia:command> elements can take
         multiple steps as child elements; they also allow to specify (through pattern matching) to which 
         states the steps apply.</li>
       </ul>

       <p>As can be seen, <sapia:command>include</sapia:command> elements are used to indicate if given steps apply to given 
        states; <sapia:command>exclude</sapia:command> elements can also be used to explicitely indicate that the
        corresponding steps are not to be applied to the matching states. The "id" attribute in this case is a pattern
        that is tested against all configured state identifiers; the corresponding states will be included or excluded
        based on the result of the matching operation.</p>

        <p>Inclusion and exclusion works as follows:</p>

        <ul>
          <li>no includes and no excludes: the steps apply to all states;</li>
          <li>includes without excludes: the steps apply to matched included states only;</li>
          <li>includes with excludes: the steps apply to matched included states, to the exclusion of matched excluded
              states;</li>
          <li>excludes without includes: the steps apply to all states, to the exclusion of matched excluded states;</li>
        </ul>
				
        <p/>
        <sapia:note>Global steps are subject to <a href="#module_inheritance">module inheritance</a>.</sapia:note>				

      </sapia:sect3>
			
			<sapia:sect3 title="Enter/Exit Triggers">
			  <p>Interceptors and global steps are executed each time given states are triggered. At times, triggering states (or,
				more precisely, "executables") upon entering and exiting a state machine might be desirable: for example, in a given 
				application, you might want to check upon exiting a state machine that a transaction has been either committed or 
				rolled back, so that it is not left in an inconsistent state. Or, for example, you might want to check user 
				permissions before actual business logic is actually executed. The configuration below demonstrates how this could be done:</p>
				
<sapia:code><![CDATA[...
  <stm:globals>
    ...
    <enter>
      <myApp:checkRole role="admin" />          
    </enter>
    
    <exit>
      <myApp:commitPendingTransaction />                    
    </exit>   
    ...
  </stm:globals>         
...]]></sapia:code>       	

        <p/>
        <sapia:note>Enter/exit triggers are subject to <a href="#module_inheritance">module inheritance</a>.</sapia:note>
			</sapia:sect3>
      
      <sapia:sect3 title="Access Restriction">
        <p>In a more or less complex application, states might be decomposed as to be reused amongst different
        other states, to such an extent that some states might only be triggered by other states, and not by
        client applications. Even more: it might be necessary in some cases to forbid access to such states
        from client applications - making the states "private" (i.e.: have their access granted to other states
        ONLY).</p>
        <p>The configuration supports such access restrictions, through a notation analoguous to the one used
        to defined globals steps. The example below illustrates this:</p>
        
<sapia:code><![CDATA[...
<stm:globals>
  <private>
    <include id="do*">   
  </private>
  ...
</stm:globals>
...]]></sapia:code>

        <p>In the example above, the notation specifies that all states matching the given pattern can
        be triggered by other states only, and not by client applications - pattern matching and inclusion/exclusion
        rules work identically as explained previously. Any attempt to trigger a private state from "outside" a 
        state machine will fire a <sapia:class>StateAccessException</sapia:class>.</p>
        
      </sapia:sect3>
      <sapia:sect3 title="State References">
        <p>State references are just that: they refer to states. To be clearer, a state reference is a   
	<sapia:class>Step</sapia:class> that takes the identifier of a given state, an delegates its execution to it.
        The example below demonstrates this:</p>
<sapia:code><![CDATA[...
<stm:state id="checkCreditCardNumber">
  ...
</stm:state>

<stm:state id="checkOutShoppingCart">
  <example:checkInventory />
  <stm:stateRef id="checkCreditCardNumber" />
  <exampe:makePayment />
</stm:state>
...]]></sapia:code>
      </sapia:sect3>
      <sapia:sect3 title="Modules">
        
        <sapia:sect4 title="Basics">       
        <p>Once you have defined a state machine, you can reuse it in another state machine; this allows you to
        reuse functionality, without risking state identifier collisions. Indeed, in theory, without proper precautions, 
        state identifiers might collide: two separate state machine configurations embedded into a single one could 
        result in state identifiers being used more than once.</p>
      
        <p>To prevent this, when you "include" a state machine in another through configuration, you use the
        <sapia:command>stm:module</sapia:command> element - that encapsulates a single
        <sapia:command>stm:states</sapia:command> element:</p>

<sapia:code><![CDATA[...
<stm:module name="shoppingCart">
  <stm:states>
    ...
  </stm:states>
</stm:module>

<stm:state id="buy">
  <stm:stateRef id="checkInventory" module="shoppingCart" />
  ...
</stm:state>
...]]></sapia:code>

       <p>The example above shows how you embed a state machine into another state machine; the
       embedded state machine is in its own scope (it is not physically merged with the embedding state machine, 
       and therefore no name collisions risk occurring). An embedded state machine is known as a "module".</p>
      
       <p>To trigger the execution of a state in a module, you must specify the name of that module. The 
       <sapia:class>StateMachine</sapia:class> class as an <sapia:command>execute()</sapia:command> method that 
       takes a module name as an argument - in addition to the state identifier. The example also shows that the 
       <sapia:command>stateRef</sapia:command> element can in addition take the name of the module to which its 
       referred state belongs.</p>
       </sapia:sect4>
       
       <sapia:sect4 title="Module Files">

       <p>In a real-life scenario, when you will embed another state machine as a module, you will probably want 
       to refer to the file that contains that state machine's configuration - otherwise, there is no point. 
       You can use the <sapia:command>soto:include</sapia:command> element for this:</p>

<sapia:code><![CDATA[...
<stm:module name="shoppingCart" 
            uri="/opt/some/path/resources/shoppingStateMachine.xml" />

<stm:state id="buy">
  <stm:stateRef id="checkInventory" module="shoppingCart" />
  ...
</stm:state>
...]]></sapia:code>

        <p/>

        <sapia:note>
	In addition, modules externally linked with a URI are automatically reloaded if their
	corresponding file is modified. In addition, the <sapia:command>stm:module</sapia:command>
	tag implementation treats URIs in the same way as the <sapia:command>soto:include</sapia:command>
	tag - see that tag's <a href="../home.html#file_includes" target="target_window">documentation</a> for more info.
	</sapia:note>
	
       </sapia:sect4>
			 <sapia:sect4 title="Hierarchical Module Access">
			   <p>When an application grows, a convenient approach is to subdivide business logic
				 into multiple modules. Subdivisions typically follow a hierarchical approach: at the top level,
				 you have the "main" state machine. And then you add modules under that state machine that address 
				 specific set of functionalities in the application. Eventually, modules also have sub-modules, and so on.
				 </p>
				 <p>Such a design implies that some precise way of accessing given states in given modules
				 must be provided. The framework offers exactly that, through the 
				 <sapia:class target="statepath" link="maven/api/org/sapia/soto/state/StatePath.html">StatePath</sapia:class>
				 class (having a look at the Javadoc is a must). A "state path" is a path to a state within a module - or 
				 within a module hierarchy (it is analogous to a file path). You create a <sapia:class>StatePath</sapia:class> programmatically 
				 like so:</p>
<sapia:code>
StatePath somePath = StatePath.parse("module_1/module_1_1/stateToExec");
</sapia:code>
         <p>And then you use your <sapia:class>StatePath</sapia:class> instance like so:</p>
				 
<sapia:code>
Result res = machine.execute(somePath, new ContextImpl());
</sapia:code>
         <p>The last segment in the path corresponds to the actual state to trigger; the preceding segments
				 correspond to the names of the modules that are the ancestors of the indicated state.</p>
			 </sapia:sect4>
        <sapia:sect4 title="Anonymous Modules">
	  <p>As we have seen, modules are "usually" specified with a name. This is not mandatory: modules
	  can be "anonymous". In such a case, they just "extend" the state machine to which they belong
	  with the states that they themselves hold; these states can be referred to normally, without specifiying
	  a module name or anything. The example below illustrates this:
	  </p>
	  
<sapia:code><![CDATA[...
<stm:module uri="/opt/some/path/resources/shoppingStateMachine.xml" />

<stm:state id="buy">
  <stm:stateRef id="checkInventory" />
  ...
</stm:state>
...]]></sapia:code>

          <p>
	    When a state machine that has anonymous modules bound to it receives a request to execute a state, it first
	    checks its own states; then, if no state is found, it looks in its anonymous modules (in the order in which
	    these modules where specified).
	  </p>
	</sapia:sect4>
	
      <sapia:sect4 title="Module Inheritance" alias="module_inheritance">
      
        <p>Consider the following:</p>
      
<sapia:code><![CDATA[...
<stm:module uri="/opt/some/path/resources/shoppingStateMachine.xml" 
            inheritGlobals="true"
	    inheritModules="true"/>

<stm:state id="buy">
  <stm:stateRef id="checkInventory" />
  ...
</stm:state>
...]]></sapia:code>      

        <p>The <sapia:command>inheritGlobals</sapia:command> and <sapia:command>inheritModules</sapia:command>
	attributes respectively indicate if a module (or, rather, the state machine defined as part of that module)
	should inherit: a) the modules of its parent state machine; b) the "globals" of the parent state machine.</p>
	
	<p>If the <sapia:command>inheritModules</sapia:command> flag is true, then a state machine will defer state
	lookup to its parent state machine if the lookup has failed. More clearly: a state machine bound to another
	as a module delegates state lookup to its parent state machine upon lookup failure, thereby implementing a
	sort of "inheritance".</p>
	
	<p>By the same token, the globals (defined with a <sapia:command>stm:globals</sapia:command> element) that are part
	of a parent state machine will be inherited by all child state machines (modules) that have their 
	<sapia:command>inheritGlobals</sapia:command> flag set to true. This means that children will inherit the enter/exit
	triggers, global steps</p>
	
      
      </sapia:sect4>
 
      </sapia:sect3>
      <sapia:sect3 title="Dealing with Errors">
			
			  <sapia:sect4 title="Basics">
        <p>States and steps can signal errors to the state machine by using the <sapia:command>error(...)</sapia:command>
        methods of the <sapia:class link="maven/api/org/sapia/soto/state/Result.html">Result</sapia:class> class. 
        Before executing the "next" state, a state machine will check if an error has been signaled; if so, it will
        abort the current execution and throw a 
        <sapia:class link="maven/api/org/sapia/soto/state/StateExecException.html">StateExecException</sapia:class>.</p>

        <p>The exception to this rule is when a state machine detects that an error has been "handled"; in this case,
        execution will be stopped, but no exception will be thrown. But what exactly does that mean? Let's talk about the            
	      way the <sapia:class>StepState</sapia:class> works: we have seen that it is a state that can take nested steps.
        At runtime, a <sapia:class>StepState</sapia:class> instance will sequentially execute its steps; if an error is 
        "signaled" by one of the steps, then the instance will abort its execution. If the identifier of an "error
        handling" state has been defined on the state, the instance will redirect the execution flow to that state 
        (in a manner similar to a state reference). The state implementation is expected to "handle" the
        error:  that is, it is expected to call the <sapia:command>handleError()</sapia:command> method (which returns an
        <sapia:class>Err</sapia:class> instance). Internally, the method sets a flag on the result, indicating that the
        error has been handled - and that, therefore, no exception needs to be thrown. The following illustrates what we
        mean:</p>

<sapia:code><![CDATA[...

<stm:state id="doSomething" 
           success="doSomethingElse" 
	   error="displayError">
  ...
</stm:state>

<stm:state id="doSomethingElse">
  ...
</stm:state>

<example:error id="displayError" />
...]]></sapia:code>

        <p>In this case, our error handling state could be implemented as follows:</p>
<sapia:code>
public void execute(Result res){
  System.out.println("Error occurred: " + res.handleError().getMsg());  
}
</sapia:code>

        <p>As explained, the state implementation calls the error method on the result. This has the effect
        of telling to the state machine that it needs not worrying about the error, since it has been
        handled already.</p>
				</sapia:sect4>
				<sapia:sect4 title="Error Handlers">
				  <p>A more elegant and generic way to handle errors is to implement 
					<sapia:class target="error_handler" link="maven/api/org/sapia/soto/state/ErrorHandler.html">ErrorHandler</sapia:class>s 
					that are in charge of handling given types of errors. Error handlers are plugged into
					the framework as a chain of responsibility: when an error occurs and has not been handled 
					(see explanations further above for the meaning of "handled" in this context), it is pushed onto the execution
					context's stack and passed to the chain of responsibility. Each handler in the chain has its <sapia:command>handle()</sapia:command>
					method invoked; the method must return <sapia:command>true</sapia:command> if it could handle the error,
					or <sapia:command>false</sapia:command> otherwise. In the latter case, the next handler in the chain is invoked,
					and so on, until the error could be handled, or until the end of the chain is reached. If the end of the chain
					is reached without the error being handled, then the state machine will throw a 
					<sapia:class>StateExecException</sapia:class>.</p>
					
					<p>A typical error handler would look like this:</p>
<sapia:code>
public boolean handle(Result result) {
  Err err = (Err) result.getContext().currentObject();
  if(err.getThrowable() != null) {
    // do something
    return true;
  }
  return false;
}
</sapia:code>
					
					<p>Error handlers are plugged through configuration, as part of a state machine's global parameters. The snippet
					below demonstrates the use of a specific error handler (configured as the <sapia:command>stm:matchError</sapia:command>
					tag): </p>
<sapia:code><![CDATA[...
<stm:globals>
  ...
  <errorHandlers>
    <stm:matchError pattern="**">
      <stm:groovy>
        <import>org.apache.commons.logging.LogFactory</import>
        log = LogFactory.getLog("ErrorHandler");
        ctx = result.getContext();
        err = ctx.currentObject();
        if(err.getThrowable() != null){
          log.error("System error", err.getThrowable());
        }
        else{
          log.error("Error: " + err.getMsg());
        }
      </stm:groovy>
      <stm:stateRef module="common" id="viewSystemError" />              
    </stm:matchError>
  </errorHandlers>
  ...
</stm:globals>
...]]></sapia:code>
        <p>The <sapia:class target="error_handler" link="maven/api/org/sapia/soto/state/MatchError.html">MatchError</sapia:class>
				class implements an error handler that is meant to hold <sapia:class>Executable</sapia:class>s. An instance of
				the <sapia:class>MatchError</sapia:class> class is configured with a pattern indicating the type of exception that
				the instance handles. In the above case, our instance is meant to handle all exceptions, but we could change this if
				we wanted to provide error messages or status codes that correspond to the actual errors being handled.
				</p>
				<p>
				The above shows a <sapia:command>stm:matchError</sapia:command> tag that holds different steps (that are part of the 
				error handling procedure): the first step consist of logging the actual error; the second step consists of 
				a <sapia:command>stm:stateRef</sapia:command> tag that actually refers to a state in the state machine. In this case,
				the state is in charge of displaying a user-friendly error message. This means that, from an error handler, we have access
				to the state machine, and therefore that error-handling logic can make use of the state machine functionality.
				</p>
				<p>The pattern matching notation supported by the <sapia:command>stm:matchError</sapia:command> tag is analogous to Ant's
				path pattern matching one. Except that in this case, the pattern is matched:
				<ol>
				  <li>Against the name of the class of the <sapia:class>Throwable</sapia:class> that the <sapia:class>Err</sapia:class>
					instance encapsulates.</li>
				  <li>If the above fails, against the message (if any) of the <sapia:class>Err</sapia:class> instance.</li>					
				</ol>
				If the match is successful, then the nested exectubables are processed and the <sapia:command>handle</sapia:command>
				method of the current <sapia:class>MatchError</sapia:class> instance returns <sapia:command>true</sapia:command>.
				</p>
				<sapia:note>If a state machine is included as a module within another one, then it inherits the error handlers of its parent.</sapia:note>
				</sapia:sect4>
      </sapia:sect3>
      
      <sapia:sect3 title="Aborting">
        <p>At times, you might want to wish that a given execution flow be stopped, even if no error
	has occurred. This can be done by calling the <sapia:command>abort()</sapia:command> method on
	the <sapia:class>Result</sapia:class>.
	</p>
      </sapia:sect3>

    </sapia:sect2>
    <sapia:sect2 title="Conclusion">
      <p>To inquire about available tags not mentioned in this page, 
      have a look at the the <a href="doc/StmTagReference.pdf">STM tag reference</a>.</p>
    </sapia:sect2>
  </sapia:sect1>

</sapia:page>
